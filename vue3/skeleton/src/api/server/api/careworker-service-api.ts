/* tslint:disable */
/* eslint-disable */
/**
 * server/v1/api.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CareworkerAccount } from '../models';
// @ts-ignore
import { CareworkerAccountDepartment } from '../models';
// @ts-ignore
import { CareworkerAccountPosition } from '../models';
// @ts-ignore
import { CareworkerAccountRole } from '../models';
// @ts-ignore
import { CareworkerAccountSession } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountDepartmentsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountPositionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountPositionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountRolesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountRolesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountSessionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountSessionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateAccountsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateBedsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateBedsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateConfigsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateConfigsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateCustomersRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateCustomersResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateDepartmentsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateDictDataSliceRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateDictDataSliceResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateDictTypesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateDictTypesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateEmployeesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateEmployeesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateFileCategroysRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateFileCategroysResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateFilesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateFilesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateMenusRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateMenusResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateNoticeRecordsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateNoticeRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateNoticeSettingsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateNoticeSettingsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateOperationLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateOperationLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreatePositionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreatePositionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateProjectsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateProjectsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRechargeOrdersRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRechargeOrdersResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRefundLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRefundLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRefundRecordsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRefundRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRoleMenusRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRoleMenusResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRolesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateRolesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateSmsLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateSmsLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchCreateTenantsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchCreateTenantsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteAccountDepartmentsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteAccountPositionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteAccountRolesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteAccountSessionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteAccountsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteBedsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteConfigsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteCustomersRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteDepartmentsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteDictDataSliceRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteDictTypesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteEmployeesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteFileCategroysRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteFilesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteMenusRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteNoticeRecordsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteNoticeSettingsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteOperationLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeletePositionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteProjectsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteRechargeOrdersRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteRefundLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteRefundRecordsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteRoleMenusRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteRolesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteSmsLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchDeleteTenantsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountDepartmentsByAccountIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountDepartmentsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountPositionsByAccountIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountPositionsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountPositionsByPositionIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountPositionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountRolesByAccountIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountRolesByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountRolesByRoleIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountRolesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountSessionsByAccountIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountSessionsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountSessionsByTerminalRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountSessionsByTokenRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountSessionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountsByNameRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetAccountsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetBedsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetBedsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetBedsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetConfigsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetConfigsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetConfigsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetCustomersByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetCustomersByNameRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetCustomersBySnRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetCustomersByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetCustomersResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetDepartmentsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetDepartmentsByProjectIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetDepartmentsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetDictDataSliceByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetDictDataSliceResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetDictTypesByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetDictTypesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetEmployeesByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetEmployeesByNameRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetEmployeesByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetEmployeesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetFileCategroysByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetFileCategroysByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetFileCategroysResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetFilesByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetFilesByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetFilesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetMenusByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetMenusResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetNoticeRecordsByEmployeeIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetNoticeRecordsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetNoticeRecordsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetNoticeRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetNoticeSettingsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetNoticeSettingsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetNoticeSettingsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetOperationLogsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetOperationLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetPositionsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetPositionsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetPositionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetProjectsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetProjectsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetProjectsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetRechargeOrdersByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRechargeOrdersByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRechargeOrdersResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetRefundLogsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRefundLogsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRefundLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetRefundRecordsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRefundRecordsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRefundRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetRoleMenusByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRoleMenusByMenuIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRoleMenusByRoleIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRoleMenusResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetRolesByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetRolesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetSmsLogsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetSmsLogsByTenantIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetSmsLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchGetTenantsByIdRequest } from '../models';
// @ts-ignore
import { CareworkerBatchGetTenantsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountDepartmentsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountPositionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountPositionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountRolesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountRolesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountSessionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountSessionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateAccountsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateBedsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateBedsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateConfigsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateConfigsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateCustomersRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateCustomersResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateDepartmentsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateDictDataSliceRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateDictDataSliceResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateDictTypesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateDictTypesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateEmployeesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateEmployeesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateFileCategroysRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateFileCategroysResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateFilesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateFilesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateMenusRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateMenusResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateNoticeRecordsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateNoticeRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateNoticeSettingsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateNoticeSettingsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateOperationLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateOperationLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdatePositionsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdatePositionsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateProjectsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateProjectsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRechargeOrdersRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRechargeOrdersResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRefundLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRefundLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRefundRecordsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRefundRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRoleMenusRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRoleMenusResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRolesRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateRolesResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateSmsLogsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateSmsLogsResponse } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateTenantsRequest } from '../models';
// @ts-ignore
import { CareworkerBatchUpdateTenantsResponse } from '../models';
// @ts-ignore
import { CareworkerBed } from '../models';
// @ts-ignore
import { CareworkerConfig } from '../models';
// @ts-ignore
import { CareworkerCustomer } from '../models';
// @ts-ignore
import { CareworkerDepartment } from '../models';
// @ts-ignore
import { CareworkerDictData } from '../models';
// @ts-ignore
import { CareworkerDictType } from '../models';
// @ts-ignore
import { CareworkerEmployee } from '../models';
// @ts-ignore
import { CareworkerFile } from '../models';
// @ts-ignore
import { CareworkerFileCategroy } from '../models';
// @ts-ignore
import { CareworkerListAccountDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerListAccountPositionsResponse } from '../models';
// @ts-ignore
import { CareworkerListAccountRolesResponse } from '../models';
// @ts-ignore
import { CareworkerListAccountSessionsResponse } from '../models';
// @ts-ignore
import { CareworkerListAccountsResponse } from '../models';
// @ts-ignore
import { CareworkerListBedsResponse } from '../models';
// @ts-ignore
import { CareworkerListConfigsResponse } from '../models';
// @ts-ignore
import { CareworkerListCustomersResponse } from '../models';
// @ts-ignore
import { CareworkerListDepartmentsResponse } from '../models';
// @ts-ignore
import { CareworkerListDictDataSliceResponse } from '../models';
// @ts-ignore
import { CareworkerListDictTypesResponse } from '../models';
// @ts-ignore
import { CareworkerListEmployeesResponse } from '../models';
// @ts-ignore
import { CareworkerListFileCategroysResponse } from '../models';
// @ts-ignore
import { CareworkerListFilesResponse } from '../models';
// @ts-ignore
import { CareworkerListMenusResponse } from '../models';
// @ts-ignore
import { CareworkerListNoticeRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerListNoticeSettingsResponse } from '../models';
// @ts-ignore
import { CareworkerListOperationLogsResponse } from '../models';
// @ts-ignore
import { CareworkerListPositionsResponse } from '../models';
// @ts-ignore
import { CareworkerListProjectsResponse } from '../models';
// @ts-ignore
import { CareworkerListRechargeOrdersResponse } from '../models';
// @ts-ignore
import { CareworkerListRefundLogsResponse } from '../models';
// @ts-ignore
import { CareworkerListRefundRecordsResponse } from '../models';
// @ts-ignore
import { CareworkerListRoleMenusResponse } from '../models';
// @ts-ignore
import { CareworkerListRolesResponse } from '../models';
// @ts-ignore
import { CareworkerListSmsLogsResponse } from '../models';
// @ts-ignore
import { CareworkerListTenantsResponse } from '../models';
// @ts-ignore
import { CareworkerMenu } from '../models';
// @ts-ignore
import { CareworkerNoticeRecord } from '../models';
// @ts-ignore
import { CareworkerNoticeSetting } from '../models';
// @ts-ignore
import { CareworkerOperationLog } from '../models';
// @ts-ignore
import { CareworkerPosition } from '../models';
// @ts-ignore
import { CareworkerProject } from '../models';
// @ts-ignore
import { CareworkerRechargeOrder } from '../models';
// @ts-ignore
import { CareworkerRefundLog } from '../models';
// @ts-ignore
import { CareworkerRefundRecord } from '../models';
// @ts-ignore
import { CareworkerRole } from '../models';
// @ts-ignore
import { CareworkerRoleMenu } from '../models';
// @ts-ignore
import { CareworkerSmsLog } from '../models';
// @ts-ignore
import { CareworkerTenant } from '../models';
// @ts-ignore
import { RpcStatus } from '../models';
/**
 * CareworkerServiceApi - axios parameter creator
 * @export
 */
export const CareworkerServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CareworkerBatchCreateAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountDepartments: async (body: CareworkerBatchCreateAccountDepartmentsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateAccountDepartments.');
            }
            const localVarPath = `/api/v1/accountDepartments:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountPositions: async (body: CareworkerBatchCreateAccountPositionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateAccountPositions.');
            }
            const localVarPath = `/api/v1/accountPositions:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountRoles: async (body: CareworkerBatchCreateAccountRolesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateAccountRoles.');
            }
            const localVarPath = `/api/v1/accountRoles:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountSessions: async (body: CareworkerBatchCreateAccountSessionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateAccountSessions.');
            }
            const localVarPath = `/api/v1/accountSessions:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccounts: async (body: CareworkerBatchCreateAccountsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateAccounts.');
            }
            const localVarPath = `/api/v1/accounts:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateBeds: async (body: CareworkerBatchCreateBedsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateBeds.');
            }
            const localVarPath = `/api/v1/beds:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateConfigs: async (body: CareworkerBatchCreateConfigsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateConfigs.');
            }
            const localVarPath = `/api/v1/configs:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateCustomers: async (body: CareworkerBatchCreateCustomersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateCustomers.');
            }
            const localVarPath = `/api/v1/customers:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateDepartments: async (body: CareworkerBatchCreateDepartmentsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateDepartments.');
            }
            const localVarPath = `/api/v1/departments:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateDictDataSlice: async (body: CareworkerBatchCreateDictDataSliceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateDictDataSlice.');
            }
            const localVarPath = `/api/v1/dictDataSlice:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateDictTypes: async (body: CareworkerBatchCreateDictTypesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateDictTypes.');
            }
            const localVarPath = `/api/v1/dictTypes:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateEmployees: async (body: CareworkerBatchCreateEmployeesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateEmployees.');
            }
            const localVarPath = `/api/v1/employees:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateFileCategroys: async (body: CareworkerBatchCreateFileCategroysRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateFileCategroys.');
            }
            const localVarPath = `/api/v1/fileCategroys:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateFiles: async (body: CareworkerBatchCreateFilesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateFiles.');
            }
            const localVarPath = `/api/v1/files:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateMenus: async (body: CareworkerBatchCreateMenusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateMenus.');
            }
            const localVarPath = `/api/v1/menus:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateNoticeRecords: async (body: CareworkerBatchCreateNoticeRecordsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateNoticeRecords.');
            }
            const localVarPath = `/api/v1/noticeRecords:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateNoticeSettings: async (body: CareworkerBatchCreateNoticeSettingsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateNoticeSettings.');
            }
            const localVarPath = `/api/v1/noticeSettings:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateOperationLogs: async (body: CareworkerBatchCreateOperationLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateOperationLogs.');
            }
            const localVarPath = `/api/v1/operationLogs:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreatePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreatePositions: async (body: CareworkerBatchCreatePositionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreatePositions.');
            }
            const localVarPath = `/api/v1/positions:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateProjects: async (body: CareworkerBatchCreateProjectsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateProjects.');
            }
            const localVarPath = `/api/v1/projects:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRechargeOrders: async (body: CareworkerBatchCreateRechargeOrdersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateRechargeOrders.');
            }
            const localVarPath = `/api/v1/rechargeOrders:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRefundLogs: async (body: CareworkerBatchCreateRefundLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateRefundLogs.');
            }
            const localVarPath = `/api/v1/refundLogs:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRefundRecords: async (body: CareworkerBatchCreateRefundRecordsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateRefundRecords.');
            }
            const localVarPath = `/api/v1/refundRecords:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRoleMenus: async (body: CareworkerBatchCreateRoleMenusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateRoleMenus.');
            }
            const localVarPath = `/api/v1/roleMenus:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRoles: async (body: CareworkerBatchCreateRolesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateRoles.');
            }
            const localVarPath = `/api/v1/roles:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateSmsLogs: async (body: CareworkerBatchCreateSmsLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateSmsLogs.');
            }
            const localVarPath = `/api/v1/smsLogs:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateTenants: async (body: CareworkerBatchCreateTenantsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchCreateTenants.');
            }
            const localVarPath = `/api/v1/tenants:batchCreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountDepartments: async (body: CareworkerBatchDeleteAccountDepartmentsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteAccountDepartments.');
            }
            const localVarPath = `/api/v1/accountDepartments:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountPositions: async (body: CareworkerBatchDeleteAccountPositionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteAccountPositions.');
            }
            const localVarPath = `/api/v1/accountPositions:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountRoles: async (body: CareworkerBatchDeleteAccountRolesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteAccountRoles.');
            }
            const localVarPath = `/api/v1/accountRoles:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountSessions: async (body: CareworkerBatchDeleteAccountSessionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteAccountSessions.');
            }
            const localVarPath = `/api/v1/accountSessions:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccounts: async (body: CareworkerBatchDeleteAccountsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteAccounts.');
            }
            const localVarPath = `/api/v1/accounts:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteBeds: async (body: CareworkerBatchDeleteBedsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteBeds.');
            }
            const localVarPath = `/api/v1/beds:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteConfigs: async (body: CareworkerBatchDeleteConfigsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteConfigs.');
            }
            const localVarPath = `/api/v1/configs:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteCustomers: async (body: CareworkerBatchDeleteCustomersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteCustomers.');
            }
            const localVarPath = `/api/v1/customers:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteDepartments: async (body: CareworkerBatchDeleteDepartmentsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteDepartments.');
            }
            const localVarPath = `/api/v1/departments:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteDictDataSlice: async (body: CareworkerBatchDeleteDictDataSliceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteDictDataSlice.');
            }
            const localVarPath = `/api/v1/dictDataSlice:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteDictTypes: async (body: CareworkerBatchDeleteDictTypesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteDictTypes.');
            }
            const localVarPath = `/api/v1/dictTypes:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteEmployees: async (body: CareworkerBatchDeleteEmployeesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteEmployees.');
            }
            const localVarPath = `/api/v1/employees:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteFileCategroys: async (body: CareworkerBatchDeleteFileCategroysRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteFileCategroys.');
            }
            const localVarPath = `/api/v1/fileCategroys:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteFiles: async (body: CareworkerBatchDeleteFilesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteFiles.');
            }
            const localVarPath = `/api/v1/files:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteMenus: async (body: CareworkerBatchDeleteMenusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteMenus.');
            }
            const localVarPath = `/api/v1/menus:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteNoticeRecords: async (body: CareworkerBatchDeleteNoticeRecordsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteNoticeRecords.');
            }
            const localVarPath = `/api/v1/noticeRecords:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteNoticeSettings: async (body: CareworkerBatchDeleteNoticeSettingsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteNoticeSettings.');
            }
            const localVarPath = `/api/v1/noticeSettings:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteOperationLogs: async (body: CareworkerBatchDeleteOperationLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteOperationLogs.');
            }
            const localVarPath = `/api/v1/operationLogs:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeletePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeletePositions: async (body: CareworkerBatchDeletePositionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeletePositions.');
            }
            const localVarPath = `/api/v1/positions:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteProjects: async (body: CareworkerBatchDeleteProjectsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteProjects.');
            }
            const localVarPath = `/api/v1/projects:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRechargeOrders: async (body: CareworkerBatchDeleteRechargeOrdersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteRechargeOrders.');
            }
            const localVarPath = `/api/v1/rechargeOrders:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRefundLogs: async (body: CareworkerBatchDeleteRefundLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteRefundLogs.');
            }
            const localVarPath = `/api/v1/refundLogs:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRefundRecords: async (body: CareworkerBatchDeleteRefundRecordsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteRefundRecords.');
            }
            const localVarPath = `/api/v1/refundRecords:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRoleMenus: async (body: CareworkerBatchDeleteRoleMenusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteRoleMenus.');
            }
            const localVarPath = `/api/v1/roleMenus:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRoles: async (body: CareworkerBatchDeleteRolesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteRoles.');
            }
            const localVarPath = `/api/v1/roles:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteSmsLogs: async (body: CareworkerBatchDeleteSmsLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteSmsLogs.');
            }
            const localVarPath = `/api/v1/smsLogs:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteTenants: async (body: CareworkerBatchDeleteTenantsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchDeleteTenants.');
            }
            const localVarPath = `/api/v1/tenants:batchDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountDepartmentsByAccountId: async (body: CareworkerBatchGetAccountDepartmentsByAccountIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountDepartmentsByAccountId.');
            }
            const localVarPath = `/api/v1/accountDepartments:batchByAccountId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountDepartmentsByDepartmentId: async (body: CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountDepartmentsByDepartmentId.');
            }
            const localVarPath = `/api/v1/accountDepartments:batchByDepartmentId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountDepartmentsById: async (body: CareworkerBatchGetAccountDepartmentsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountDepartmentsById.');
            }
            const localVarPath = `/api/v1/accountDepartments:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountPositionsByAccountId: async (body: CareworkerBatchGetAccountPositionsByAccountIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountPositionsByAccountId.');
            }
            const localVarPath = `/api/v1/accountPositions:batchByAccountId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountPositionsById: async (body: CareworkerBatchGetAccountPositionsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountPositionsById.');
            }
            const localVarPath = `/api/v1/accountPositions:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByPositionIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountPositionsByPositionId: async (body: CareworkerBatchGetAccountPositionsByPositionIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountPositionsByPositionId.');
            }
            const localVarPath = `/api/v1/accountPositions:batchByPositionId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountRolesByAccountId: async (body: CareworkerBatchGetAccountRolesByAccountIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountRolesByAccountId.');
            }
            const localVarPath = `/api/v1/accountRoles:batchByAccountId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountRolesById: async (body: CareworkerBatchGetAccountRolesByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountRolesById.');
            }
            const localVarPath = `/api/v1/accountRoles:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByRoleIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountRolesByRoleId: async (body: CareworkerBatchGetAccountRolesByRoleIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountRolesByRoleId.');
            }
            const localVarPath = `/api/v1/accountRoles:batchByRoleId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsByAccountId: async (body: CareworkerBatchGetAccountSessionsByAccountIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountSessionsByAccountId.');
            }
            const localVarPath = `/api/v1/accountSessions:batchByAccountId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsById: async (body: CareworkerBatchGetAccountSessionsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountSessionsById.');
            }
            const localVarPath = `/api/v1/accountSessions:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByTerminalRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsByTerminal: async (body: CareworkerBatchGetAccountSessionsByTerminalRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountSessionsByTerminal.');
            }
            const localVarPath = `/api/v1/accountSessions:batchByTerminal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsByToken: async (body: CareworkerBatchGetAccountSessionsByTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountSessionsByToken.');
            }
            const localVarPath = `/api/v1/accountSessions:batchByToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountsById: async (body: CareworkerBatchGetAccountsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountsById.');
            }
            const localVarPath = `/api/v1/accounts:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountsByName: async (body: CareworkerBatchGetAccountsByNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountsByName.');
            }
            const localVarPath = `/api/v1/accounts:batchByName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountsByTenantId: async (body: CareworkerBatchGetAccountsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetAccountsByTenantId.');
            }
            const localVarPath = `/api/v1/accounts:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetBedsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetBedsById: async (body: CareworkerBatchGetBedsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetBedsById.');
            }
            const localVarPath = `/api/v1/beds:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetBedsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetBedsByTenantId: async (body: CareworkerBatchGetBedsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetBedsByTenantId.');
            }
            const localVarPath = `/api/v1/beds:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetConfigsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetConfigsById: async (body: CareworkerBatchGetConfigsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetConfigsById.');
            }
            const localVarPath = `/api/v1/configs:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetConfigsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetConfigsByTenantId: async (body: CareworkerBatchGetConfigsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetConfigsByTenantId.');
            }
            const localVarPath = `/api/v1/configs:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersById: async (body: CareworkerBatchGetCustomersByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetCustomersById.');
            }
            const localVarPath = `/api/v1/customers:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersByName: async (body: CareworkerBatchGetCustomersByNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetCustomersByName.');
            }
            const localVarPath = `/api/v1/customers:batchByName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersBySnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersBySn: async (body: CareworkerBatchGetCustomersBySnRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetCustomersBySn.');
            }
            const localVarPath = `/api/v1/customers:batchBySn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersByTenantId: async (body: CareworkerBatchGetCustomersByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetCustomersByTenantId.');
            }
            const localVarPath = `/api/v1/customers:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDepartmentsById: async (body: CareworkerBatchGetDepartmentsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetDepartmentsById.');
            }
            const localVarPath = `/api/v1/departments:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByProjectIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDepartmentsByProjectId: async (body: CareworkerBatchGetDepartmentsByProjectIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetDepartmentsByProjectId.');
            }
            const localVarPath = `/api/v1/departments:batchByProjectId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDepartmentsByTenantId: async (body: CareworkerBatchGetDepartmentsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetDepartmentsByTenantId.');
            }
            const localVarPath = `/api/v1/departments:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDictDataSliceByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDictDataSliceById: async (body: CareworkerBatchGetDictDataSliceByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetDictDataSliceById.');
            }
            const localVarPath = `/api/v1/dictDataSlice:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDictTypesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDictTypesById: async (body: CareworkerBatchGetDictTypesByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetDictTypesById.');
            }
            const localVarPath = `/api/v1/dictTypes:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetEmployeesById: async (body: CareworkerBatchGetEmployeesByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetEmployeesById.');
            }
            const localVarPath = `/api/v1/employees:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetEmployeesByName: async (body: CareworkerBatchGetEmployeesByNameRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetEmployeesByName.');
            }
            const localVarPath = `/api/v1/employees:batchByName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetEmployeesByTenantId: async (body: CareworkerBatchGetEmployeesByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetEmployeesByTenantId.');
            }
            const localVarPath = `/api/v1/employees:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFileCategroysByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFileCategroysById: async (body: CareworkerBatchGetFileCategroysByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetFileCategroysById.');
            }
            const localVarPath = `/api/v1/fileCategroys:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFileCategroysByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFileCategroysByTenantId: async (body: CareworkerBatchGetFileCategroysByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetFileCategroysByTenantId.');
            }
            const localVarPath = `/api/v1/fileCategroys:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFilesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFilesById: async (body: CareworkerBatchGetFilesByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetFilesById.');
            }
            const localVarPath = `/api/v1/files:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFilesByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFilesByTenantId: async (body: CareworkerBatchGetFilesByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetFilesByTenantId.');
            }
            const localVarPath = `/api/v1/files:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetMenusByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetMenusById: async (body: CareworkerBatchGetMenusByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetMenusById.');
            }
            const localVarPath = `/api/v1/menus:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByEmployeeIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeRecordsByEmployeeId: async (body: CareworkerBatchGetNoticeRecordsByEmployeeIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetNoticeRecordsByEmployeeId.');
            }
            const localVarPath = `/api/v1/noticeRecords:batchByEmployeeId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeRecordsById: async (body: CareworkerBatchGetNoticeRecordsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetNoticeRecordsById.');
            }
            const localVarPath = `/api/v1/noticeRecords:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeRecordsByTenantId: async (body: CareworkerBatchGetNoticeRecordsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetNoticeRecordsByTenantId.');
            }
            const localVarPath = `/api/v1/noticeRecords:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeSettingsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeSettingsById: async (body: CareworkerBatchGetNoticeSettingsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetNoticeSettingsById.');
            }
            const localVarPath = `/api/v1/noticeSettings:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeSettingsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeSettingsByTenantId: async (body: CareworkerBatchGetNoticeSettingsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetNoticeSettingsByTenantId.');
            }
            const localVarPath = `/api/v1/noticeSettings:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetOperationLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetOperationLogsById: async (body: CareworkerBatchGetOperationLogsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetOperationLogsById.');
            }
            const localVarPath = `/api/v1/operationLogs:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetPositionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetPositionsById: async (body: CareworkerBatchGetPositionsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetPositionsById.');
            }
            const localVarPath = `/api/v1/positions:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetPositionsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetPositionsByTenantId: async (body: CareworkerBatchGetPositionsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetPositionsByTenantId.');
            }
            const localVarPath = `/api/v1/positions:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetProjectsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetProjectsById: async (body: CareworkerBatchGetProjectsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetProjectsById.');
            }
            const localVarPath = `/api/v1/projects:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetProjectsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetProjectsByTenantId: async (body: CareworkerBatchGetProjectsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetProjectsByTenantId.');
            }
            const localVarPath = `/api/v1/projects:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRechargeOrdersByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRechargeOrdersById: async (body: CareworkerBatchGetRechargeOrdersByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRechargeOrdersById.');
            }
            const localVarPath = `/api/v1/rechargeOrders:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRechargeOrdersByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRechargeOrdersByTenantId: async (body: CareworkerBatchGetRechargeOrdersByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRechargeOrdersByTenantId.');
            }
            const localVarPath = `/api/v1/rechargeOrders:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundLogsById: async (body: CareworkerBatchGetRefundLogsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRefundLogsById.');
            }
            const localVarPath = `/api/v1/refundLogs:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundLogsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundLogsByTenantId: async (body: CareworkerBatchGetRefundLogsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRefundLogsByTenantId.');
            }
            const localVarPath = `/api/v1/refundLogs:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundRecordsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundRecordsById: async (body: CareworkerBatchGetRefundRecordsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRefundRecordsById.');
            }
            const localVarPath = `/api/v1/refundRecords:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundRecordsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundRecordsByTenantId: async (body: CareworkerBatchGetRefundRecordsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRefundRecordsByTenantId.');
            }
            const localVarPath = `/api/v1/refundRecords:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRoleMenusById: async (body: CareworkerBatchGetRoleMenusByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRoleMenusById.');
            }
            const localVarPath = `/api/v1/roleMenus:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByMenuIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRoleMenusByMenuId: async (body: CareworkerBatchGetRoleMenusByMenuIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRoleMenusByMenuId.');
            }
            const localVarPath = `/api/v1/roleMenus:batchByMenuId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByRoleIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRoleMenusByRoleId: async (body: CareworkerBatchGetRoleMenusByRoleIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRoleMenusByRoleId.');
            }
            const localVarPath = `/api/v1/roleMenus:batchByRoleId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRolesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRolesById: async (body: CareworkerBatchGetRolesByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetRolesById.');
            }
            const localVarPath = `/api/v1/roles:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetSmsLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetSmsLogsById: async (body: CareworkerBatchGetSmsLogsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetSmsLogsById.');
            }
            const localVarPath = `/api/v1/smsLogs:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetSmsLogsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetSmsLogsByTenantId: async (body: CareworkerBatchGetSmsLogsByTenantIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetSmsLogsByTenantId.');
            }
            const localVarPath = `/api/v1/smsLogs:batchByTenantId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetTenantsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetTenantsById: async (body: CareworkerBatchGetTenantsByIdRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchGetTenantsById.');
            }
            const localVarPath = `/api/v1/tenants:batchById`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountDepartments: async (body: CareworkerBatchUpdateAccountDepartmentsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateAccountDepartments.');
            }
            const localVarPath = `/api/v1/accountDepartments:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountPositions: async (body: CareworkerBatchUpdateAccountPositionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateAccountPositions.');
            }
            const localVarPath = `/api/v1/accountPositions:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountRoles: async (body: CareworkerBatchUpdateAccountRolesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateAccountRoles.');
            }
            const localVarPath = `/api/v1/accountRoles:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountSessions: async (body: CareworkerBatchUpdateAccountSessionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateAccountSessions.');
            }
            const localVarPath = `/api/v1/accountSessions:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccounts: async (body: CareworkerBatchUpdateAccountsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateAccounts.');
            }
            const localVarPath = `/api/v1/accounts:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateBeds: async (body: CareworkerBatchUpdateBedsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateBeds.');
            }
            const localVarPath = `/api/v1/beds:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateConfigs: async (body: CareworkerBatchUpdateConfigsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateConfigs.');
            }
            const localVarPath = `/api/v1/configs:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateCustomers: async (body: CareworkerBatchUpdateCustomersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateCustomers.');
            }
            const localVarPath = `/api/v1/customers:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateDepartments: async (body: CareworkerBatchUpdateDepartmentsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateDepartments.');
            }
            const localVarPath = `/api/v1/departments:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateDictDataSlice: async (body: CareworkerBatchUpdateDictDataSliceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateDictDataSlice.');
            }
            const localVarPath = `/api/v1/dictDataSlice:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateDictTypes: async (body: CareworkerBatchUpdateDictTypesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateDictTypes.');
            }
            const localVarPath = `/api/v1/dictTypes:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateEmployees: async (body: CareworkerBatchUpdateEmployeesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateEmployees.');
            }
            const localVarPath = `/api/v1/employees:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateFileCategroys: async (body: CareworkerBatchUpdateFileCategroysRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateFileCategroys.');
            }
            const localVarPath = `/api/v1/fileCategroys:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateFiles: async (body: CareworkerBatchUpdateFilesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateFiles.');
            }
            const localVarPath = `/api/v1/files:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateMenus: async (body: CareworkerBatchUpdateMenusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateMenus.');
            }
            const localVarPath = `/api/v1/menus:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateNoticeRecords: async (body: CareworkerBatchUpdateNoticeRecordsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateNoticeRecords.');
            }
            const localVarPath = `/api/v1/noticeRecords:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateNoticeSettings: async (body: CareworkerBatchUpdateNoticeSettingsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateNoticeSettings.');
            }
            const localVarPath = `/api/v1/noticeSettings:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateOperationLogs: async (body: CareworkerBatchUpdateOperationLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateOperationLogs.');
            }
            const localVarPath = `/api/v1/operationLogs:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdatePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdatePositions: async (body: CareworkerBatchUpdatePositionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdatePositions.');
            }
            const localVarPath = `/api/v1/positions:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateProjects: async (body: CareworkerBatchUpdateProjectsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateProjects.');
            }
            const localVarPath = `/api/v1/projects:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRechargeOrders: async (body: CareworkerBatchUpdateRechargeOrdersRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateRechargeOrders.');
            }
            const localVarPath = `/api/v1/rechargeOrders:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRefundLogs: async (body: CareworkerBatchUpdateRefundLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateRefundLogs.');
            }
            const localVarPath = `/api/v1/refundLogs:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRefundRecords: async (body: CareworkerBatchUpdateRefundRecordsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateRefundRecords.');
            }
            const localVarPath = `/api/v1/refundRecords:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRoleMenus: async (body: CareworkerBatchUpdateRoleMenusRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateRoleMenus.');
            }
            const localVarPath = `/api/v1/roleMenus:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRoles: async (body: CareworkerBatchUpdateRolesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateRoles.');
            }
            const localVarPath = `/api/v1/roles:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateSmsLogs: async (body: CareworkerBatchUpdateSmsLogsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateSmsLogs.');
            }
            const localVarPath = `/api/v1/smsLogs:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateTenants: async (body: CareworkerBatchUpdateTenantsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling careworkerServiceBatchUpdateTenants.');
            }
            const localVarPath = `/api/v1/tenants:batchUpdate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccount} account The Account resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Account is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccount: async (account: CareworkerAccount, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account','Required parameter account was null or undefined when calling careworkerServiceCreateAccount.');
            }
            const localVarPath = `/api/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof account !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(account !== undefined ? account : {})
                : (account || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountDepartment is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountDepartment: async (accountDepartment: CareworkerAccountDepartment, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountDepartment' is not null or undefined
            if (accountDepartment === null || accountDepartment === undefined) {
                throw new RequiredError('accountDepartment','Required parameter accountDepartment was null or undefined when calling careworkerServiceCreateAccountDepartment.');
            }
            const localVarPath = `/api/v1/accountDepartments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountDepartment !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountDepartment !== undefined ? accountDepartment : {})
                : (accountDepartment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountPosition is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountPosition: async (accountPosition: CareworkerAccountPosition, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPosition' is not null or undefined
            if (accountPosition === null || accountPosition === undefined) {
                throw new RequiredError('accountPosition','Required parameter accountPosition was null or undefined when calling careworkerServiceCreateAccountPosition.');
            }
            const localVarPath = `/api/v1/accountPositions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountPosition !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountPosition !== undefined ? accountPosition : {})
                : (accountPosition || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountRole} accountRole The AccountRole resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountRole is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountRole: async (accountRole: CareworkerAccountRole, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountRole' is not null or undefined
            if (accountRole === null || accountRole === undefined) {
                throw new RequiredError('accountRole','Required parameter accountRole was null or undefined when calling careworkerServiceCreateAccountRole.');
            }
            const localVarPath = `/api/v1/accountRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountRole !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountRole !== undefined ? accountRole : {})
                : (accountRole || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountSession} accountSession The AccountSession resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountSession is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountSession: async (accountSession: CareworkerAccountSession, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSession' is not null or undefined
            if (accountSession === null || accountSession === undefined) {
                throw new RequiredError('accountSession','Required parameter accountSession was null or undefined when calling careworkerServiceCreateAccountSession.');
            }
            const localVarPath = `/api/v1/accountSessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountSession !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountSession !== undefined ? accountSession : {})
                : (accountSession || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBed} bed The Bed resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Bed is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateBed: async (bed: CareworkerBed, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bed' is not null or undefined
            if (bed === null || bed === undefined) {
                throw new RequiredError('bed','Required parameter bed was null or undefined when calling careworkerServiceCreateBed.');
            }
            const localVarPath = `/api/v1/beds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bed !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bed !== undefined ? bed : {})
                : (bed || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerConfig} config The Config resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Config is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateConfig: async (config: CareworkerConfig, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'config' is not null or undefined
            if (config === null || config === undefined) {
                throw new RequiredError('config','Required parameter config was null or undefined when calling careworkerServiceCreateConfig.');
            }
            const localVarPath = `/api/v1/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof config !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(config !== undefined ? config : {})
                : (config || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerCustomer} customer The Customer resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Customer is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateCustomer: async (customer: CareworkerCustomer, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            if (customer === null || customer === undefined) {
                throw new RequiredError('customer','Required parameter customer was null or undefined when calling careworkerServiceCreateCustomer.');
            }
            const localVarPath = `/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof customer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(customer !== undefined ? customer : {})
                : (customer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerDepartment} department The Department resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Department is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateDepartment: async (department: CareworkerDepartment, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'department' is not null or undefined
            if (department === null || department === undefined) {
                throw new RequiredError('department','Required parameter department was null or undefined when calling careworkerServiceCreateDepartment.');
            }
            const localVarPath = `/api/v1/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof department !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(department !== undefined ? department : {})
                : (department || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerDictData} dictData The DictData resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the DictData is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateDictData: async (dictData: CareworkerDictData, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictData' is not null or undefined
            if (dictData === null || dictData === undefined) {
                throw new RequiredError('dictData','Required parameter dictData was null or undefined when calling careworkerServiceCreateDictData.');
            }
            const localVarPath = `/api/v1/dictDataSlice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dictData !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dictData !== undefined ? dictData : {})
                : (dictData || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerDictType} dictType The DictType resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the DictType is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateDictType: async (dictType: CareworkerDictType, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictType' is not null or undefined
            if (dictType === null || dictType === undefined) {
                throw new RequiredError('dictType','Required parameter dictType was null or undefined when calling careworkerServiceCreateDictType.');
            }
            const localVarPath = `/api/v1/dictTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dictType !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dictType !== undefined ? dictType : {})
                : (dictType || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerEmployee} employee The Employee resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Employee is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateEmployee: async (employee: CareworkerEmployee, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'employee' is not null or undefined
            if (employee === null || employee === undefined) {
                throw new RequiredError('employee','Required parameter employee was null or undefined when calling careworkerServiceCreateEmployee.');
            }
            const localVarPath = `/api/v1/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof employee !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(employee !== undefined ? employee : {})
                : (employee || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerFile} file The File resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the File is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateFile: async (file: CareworkerFile, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling careworkerServiceCreateFile.');
            }
            const localVarPath = `/api/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof file !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(file !== undefined ? file : {})
                : (file || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the FileCategroy is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateFileCategroy: async (fileCategroy: CareworkerFileCategroy, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileCategroy' is not null or undefined
            if (fileCategroy === null || fileCategroy === undefined) {
                throw new RequiredError('fileCategroy','Required parameter fileCategroy was null or undefined when calling careworkerServiceCreateFileCategroy.');
            }
            const localVarPath = `/api/v1/fileCategroys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileCategroy !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileCategroy !== undefined ? fileCategroy : {})
                : (fileCategroy || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerMenu} menu The Menu resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Menu is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateMenu: async (menu: CareworkerMenu, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'menu' is not null or undefined
            if (menu === null || menu === undefined) {
                throw new RequiredError('menu','Required parameter menu was null or undefined when calling careworkerServiceCreateMenu.');
            }
            const localVarPath = `/api/v1/menus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof menu !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(menu !== undefined ? menu : {})
                : (menu || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the NoticeRecord is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateNoticeRecord: async (noticeRecord: CareworkerNoticeRecord, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeRecord' is not null or undefined
            if (noticeRecord === null || noticeRecord === undefined) {
                throw new RequiredError('noticeRecord','Required parameter noticeRecord was null or undefined when calling careworkerServiceCreateNoticeRecord.');
            }
            const localVarPath = `/api/v1/noticeRecords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof noticeRecord !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(noticeRecord !== undefined ? noticeRecord : {})
                : (noticeRecord || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the NoticeSetting is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateNoticeSetting: async (noticeSetting: CareworkerNoticeSetting, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeSetting' is not null or undefined
            if (noticeSetting === null || noticeSetting === undefined) {
                throw new RequiredError('noticeSetting','Required parameter noticeSetting was null or undefined when calling careworkerServiceCreateNoticeSetting.');
            }
            const localVarPath = `/api/v1/noticeSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof noticeSetting !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(noticeSetting !== undefined ? noticeSetting : {})
                : (noticeSetting || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerOperationLog} operationLog The OperationLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the OperationLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateOperationLog: async (operationLog: CareworkerOperationLog, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationLog' is not null or undefined
            if (operationLog === null || operationLog === undefined) {
                throw new RequiredError('operationLog','Required parameter operationLog was null or undefined when calling careworkerServiceCreateOperationLog.');
            }
            const localVarPath = `/api/v1/operationLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof operationLog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(operationLog !== undefined ? operationLog : {})
                : (operationLog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerPosition} position The Position resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Position is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreatePosition: async (position: CareworkerPosition, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'position' is not null or undefined
            if (position === null || position === undefined) {
                throw new RequiredError('position','Required parameter position was null or undefined when calling careworkerServiceCreatePosition.');
            }
            const localVarPath = `/api/v1/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof position !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(position !== undefined ? position : {})
                : (position || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerProject} project The Project resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Project is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateProject: async (project: CareworkerProject, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling careworkerServiceCreateProject.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof project !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(project !== undefined ? project : {})
                : (project || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RechargeOrder is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRechargeOrder: async (rechargeOrder: CareworkerRechargeOrder, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rechargeOrder' is not null or undefined
            if (rechargeOrder === null || rechargeOrder === undefined) {
                throw new RequiredError('rechargeOrder','Required parameter rechargeOrder was null or undefined when calling careworkerServiceCreateRechargeOrder.');
            }
            const localVarPath = `/api/v1/rechargeOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof rechargeOrder !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(rechargeOrder !== undefined ? rechargeOrder : {})
                : (rechargeOrder || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRefundLog} refundLog The RefundLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RefundLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRefundLog: async (refundLog: CareworkerRefundLog, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundLog' is not null or undefined
            if (refundLog === null || refundLog === undefined) {
                throw new RequiredError('refundLog','Required parameter refundLog was null or undefined when calling careworkerServiceCreateRefundLog.');
            }
            const localVarPath = `/api/v1/refundLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof refundLog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(refundLog !== undefined ? refundLog : {})
                : (refundLog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RefundRecord is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRefundRecord: async (refundRecord: CareworkerRefundRecord, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundRecord' is not null or undefined
            if (refundRecord === null || refundRecord === undefined) {
                throw new RequiredError('refundRecord','Required parameter refundRecord was null or undefined when calling careworkerServiceCreateRefundRecord.');
            }
            const localVarPath = `/api/v1/refundRecords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof refundRecord !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(refundRecord !== undefined ? refundRecord : {})
                : (refundRecord || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRole} role The Role resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Role is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRole: async (role: CareworkerRole, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling careworkerServiceCreateRole.');
            }
            const localVarPath = `/api/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof role !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(role !== undefined ? role : {})
                : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RoleMenu is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRoleMenu: async (roleMenu: CareworkerRoleMenu, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleMenu' is not null or undefined
            if (roleMenu === null || roleMenu === undefined) {
                throw new RequiredError('roleMenu','Required parameter roleMenu was null or undefined when calling careworkerServiceCreateRoleMenu.');
            }
            const localVarPath = `/api/v1/roleMenus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof roleMenu !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(roleMenu !== undefined ? roleMenu : {})
                : (roleMenu || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerSmsLog} smsLog The SmsLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the SmsLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateSmsLog: async (smsLog: CareworkerSmsLog, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'smsLog' is not null or undefined
            if (smsLog === null || smsLog === undefined) {
                throw new RequiredError('smsLog','Required parameter smsLog was null or undefined when calling careworkerServiceCreateSmsLog.');
            }
            const localVarPath = `/api/v1/smsLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof smsLog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(smsLog !== undefined ? smsLog : {})
                : (smsLog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerTenant} tenant The Tenant resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Tenant is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateTenant: async (tenant: CareworkerTenant, parent?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling careworkerServiceCreateTenant.');
            }
            const localVarPath = `/api/v1/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tenant !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tenant !== undefined ? tenant : {})
                : (tenant || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Account to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccount: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteAccount.');
            }
            const localVarPath = `/api/v1/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountDepartment to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountDepartment: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteAccountDepartment.');
            }
            const localVarPath = `/api/v1/accountDepartments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountPosition to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountPosition: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteAccountPosition.');
            }
            const localVarPath = `/api/v1/accountPositions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountRole to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountRole: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteAccountRole.');
            }
            const localVarPath = `/api/v1/accountRoles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountSession to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountSession: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteAccountSession.');
            }
            const localVarPath = `/api/v1/accountSessions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Bed to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteBed: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteBed.');
            }
            const localVarPath = `/api/v1/beds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Config to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteConfig: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteConfig.');
            }
            const localVarPath = `/api/v1/configs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Customer to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteCustomer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteCustomer.');
            }
            const localVarPath = `/api/v1/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Department to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteDepartment: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteDepartment.');
            }
            const localVarPath = `/api/v1/departments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the DictData to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteDictData: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteDictData.');
            }
            const localVarPath = `/api/v1/dictDataSlice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the DictType to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteDictType: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteDictType.');
            }
            const localVarPath = `/api/v1/dictTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Employee to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteEmployee: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteEmployee.');
            }
            const localVarPath = `/api/v1/employees/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the File to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteFile: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteFile.');
            }
            const localVarPath = `/api/v1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the FileCategroy to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteFileCategroy: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteFileCategroy.');
            }
            const localVarPath = `/api/v1/fileCategroys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Menu to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteMenu: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteMenu.');
            }
            const localVarPath = `/api/v1/menus/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the NoticeRecord to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteNoticeRecord: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteNoticeRecord.');
            }
            const localVarPath = `/api/v1/noticeRecords/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the NoticeSetting to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteNoticeSetting: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteNoticeSetting.');
            }
            const localVarPath = `/api/v1/noticeSettings/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the OperationLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteOperationLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteOperationLog.');
            }
            const localVarPath = `/api/v1/operationLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Position to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeletePosition: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeletePosition.');
            }
            const localVarPath = `/api/v1/positions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Project to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteProject: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteProject.');
            }
            const localVarPath = `/api/v1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RechargeOrder to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRechargeOrder: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteRechargeOrder.');
            }
            const localVarPath = `/api/v1/rechargeOrders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RefundLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRefundLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteRefundLog.');
            }
            const localVarPath = `/api/v1/refundLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RefundRecord to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRefundRecord: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteRefundRecord.');
            }
            const localVarPath = `/api/v1/refundRecords/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Role to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRole: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteRole.');
            }
            const localVarPath = `/api/v1/roles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RoleMenu to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRoleMenu: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteRoleMenu.');
            }
            const localVarPath = `/api/v1/roleMenus/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the SmsLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteSmsLog: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteSmsLog.');
            }
            const localVarPath = `/api/v1/smsLogs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Tenant to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteTenant: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceDeleteTenant.');
            }
            const localVarPath = `/api/v1/tenants/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetAccountById.');
            }
            const localVarPath = `/api/v1/accounts:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountByName: async (name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling careworkerServiceGetAccountByName.');
            }
            const localVarPath = `/api/v1/accounts:byName/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetAccountByTenantId.');
            }
            const localVarPath = `/api/v1/accounts:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountDepartmentByAccountId: async (accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling careworkerServiceGetAccountDepartmentByAccountId.');
            }
            const localVarPath = `/api/v1/accountDepartments:byAccountId/{account_id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} departmentId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountDepartmentByDepartmentId: async (departmentId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'departmentId' is not null or undefined
            if (departmentId === null || departmentId === undefined) {
                throw new RequiredError('departmentId','Required parameter departmentId was null or undefined when calling careworkerServiceGetAccountDepartmentByDepartmentId.');
            }
            const localVarPath = `/api/v1/accountDepartments:byDepartmentId/{department_id}`
                .replace(`{${"departmentId"}}`, encodeURIComponent(String(departmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountDepartmentById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetAccountDepartmentById.');
            }
            const localVarPath = `/api/v1/accountDepartments:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountPositionByAccountId: async (accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling careworkerServiceGetAccountPositionByAccountId.');
            }
            const localVarPath = `/api/v1/accountPositions:byAccountId/{account_id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountPositionById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetAccountPositionById.');
            }
            const localVarPath = `/api/v1/accountPositions:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} positionId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountPositionByPositionId: async (positionId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'positionId' is not null or undefined
            if (positionId === null || positionId === undefined) {
                throw new RequiredError('positionId','Required parameter positionId was null or undefined when calling careworkerServiceGetAccountPositionByPositionId.');
            }
            const localVarPath = `/api/v1/accountPositions:byPositionId/{position_id}`
                .replace(`{${"positionId"}}`, encodeURIComponent(String(positionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountRoleByAccountId: async (accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling careworkerServiceGetAccountRoleByAccountId.');
            }
            const localVarPath = `/api/v1/accountRoles:byAccountId/{account_id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountRoleById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetAccountRoleById.');
            }
            const localVarPath = `/api/v1/accountRoles:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roleId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountRoleByRoleId: async (roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling careworkerServiceGetAccountRoleByRoleId.');
            }
            const localVarPath = `/api/v1/accountRoles:byRoleId/{role_id}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionByAccountId: async (accountId: number, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling careworkerServiceGetAccountSessionByAccountId.');
            }
            const localVarPath = `/api/v1/accountSessions:byAccountId/{account_id}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetAccountSessionById.');
            }
            const localVarPath = `/api/v1/accountSessions:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} terminal The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionByTerminal: async (terminal: boolean, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'terminal' is not null or undefined
            if (terminal === null || terminal === undefined) {
                throw new RequiredError('terminal','Required parameter terminal was null or undefined when calling careworkerServiceGetAccountSessionByTerminal.');
            }
            const localVarPath = `/api/v1/accountSessions:byTerminal/{terminal}`
                .replace(`{${"terminal"}}`, encodeURIComponent(String(terminal)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionByToken: async (token: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling careworkerServiceGetAccountSessionByToken.');
            }
            const localVarPath = `/api/v1/accountSessions:byToken/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetBedById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetBedById.');
            }
            const localVarPath = `/api/v1/beds:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetBedByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetBedByTenantId.');
            }
            const localVarPath = `/api/v1/beds:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetConfigById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetConfigById.');
            }
            const localVarPath = `/api/v1/configs:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetConfigByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetConfigByTenantId.');
            }
            const localVarPath = `/api/v1/configs:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetCustomerById.');
            }
            const localVarPath = `/api/v1/customers:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerByName: async (name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling careworkerServiceGetCustomerByName.');
            }
            const localVarPath = `/api/v1/customers:byName/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} sn The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerBySn: async (sn: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sn' is not null or undefined
            if (sn === null || sn === undefined) {
                throw new RequiredError('sn','Required parameter sn was null or undefined when calling careworkerServiceGetCustomerBySn.');
            }
            const localVarPath = `/api/v1/customers:bySn/{sn}`
                .replace(`{${"sn"}}`, encodeURIComponent(String(sn)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetCustomerByTenantId.');
            }
            const localVarPath = `/api/v1/customers:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDepartmentById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetDepartmentById.');
            }
            const localVarPath = `/api/v1/departments:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} projectId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDepartmentByProjectId: async (projectId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling careworkerServiceGetDepartmentByProjectId.');
            }
            const localVarPath = `/api/v1/departments:byProjectId/{project_id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDepartmentByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetDepartmentByTenantId.');
            }
            const localVarPath = `/api/v1/departments:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDictDataById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetDictDataById.');
            }
            const localVarPath = `/api/v1/dictDataSlice:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDictTypeById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetDictTypeById.');
            }
            const localVarPath = `/api/v1/dictTypes:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetEmployeeById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetEmployeeById.');
            }
            const localVarPath = `/api/v1/employees:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetEmployeeByName: async (name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling careworkerServiceGetEmployeeByName.');
            }
            const localVarPath = `/api/v1/employees:byName/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetEmployeeByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetEmployeeByTenantId.');
            }
            const localVarPath = `/api/v1/employees:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetFileById.');
            }
            const localVarPath = `/api/v1/files:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetFileByTenantId.');
            }
            const localVarPath = `/api/v1/files:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileCategroyById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetFileCategroyById.');
            }
            const localVarPath = `/api/v1/fileCategroys:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileCategroyByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetFileCategroyByTenantId.');
            }
            const localVarPath = `/api/v1/fileCategroys:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetMenuById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetMenuById.');
            }
            const localVarPath = `/api/v1/menus:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} employeeId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeRecordByEmployeeId: async (employeeId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeId' is not null or undefined
            if (employeeId === null || employeeId === undefined) {
                throw new RequiredError('employeeId','Required parameter employeeId was null or undefined when calling careworkerServiceGetNoticeRecordByEmployeeId.');
            }
            const localVarPath = `/api/v1/noticeRecords:byEmployeeId/{employee_id}`
                .replace(`{${"employeeId"}}`, encodeURIComponent(String(employeeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeRecordById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetNoticeRecordById.');
            }
            const localVarPath = `/api/v1/noticeRecords:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeRecordByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetNoticeRecordByTenantId.');
            }
            const localVarPath = `/api/v1/noticeRecords:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeSettingById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetNoticeSettingById.');
            }
            const localVarPath = `/api/v1/noticeSettings:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeSettingByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetNoticeSettingByTenantId.');
            }
            const localVarPath = `/api/v1/noticeSettings:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetOperationLogById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetOperationLogById.');
            }
            const localVarPath = `/api/v1/operationLogs:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetPositionById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetPositionById.');
            }
            const localVarPath = `/api/v1/positions:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetPositionByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetPositionByTenantId.');
            }
            const localVarPath = `/api/v1/positions:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetProjectById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetProjectById.');
            }
            const localVarPath = `/api/v1/projects:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetProjectByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetProjectByTenantId.');
            }
            const localVarPath = `/api/v1/projects:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRechargeOrderById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetRechargeOrderById.');
            }
            const localVarPath = `/api/v1/rechargeOrders:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRechargeOrderByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetRechargeOrderByTenantId.');
            }
            const localVarPath = `/api/v1/rechargeOrders:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundLogById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetRefundLogById.');
            }
            const localVarPath = `/api/v1/refundLogs:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundLogByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetRefundLogByTenantId.');
            }
            const localVarPath = `/api/v1/refundLogs:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundRecordById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetRefundRecordById.');
            }
            const localVarPath = `/api/v1/refundRecords:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundRecordByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetRefundRecordByTenantId.');
            }
            const localVarPath = `/api/v1/refundRecords:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetRoleById.');
            }
            const localVarPath = `/api/v1/roles:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleMenuById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetRoleMenuById.');
            }
            const localVarPath = `/api/v1/roleMenus:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} menuId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleMenuByMenuId: async (menuId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'menuId' is not null or undefined
            if (menuId === null || menuId === undefined) {
                throw new RequiredError('menuId','Required parameter menuId was null or undefined when calling careworkerServiceGetRoleMenuByMenuId.');
            }
            const localVarPath = `/api/v1/roleMenus:byMenuId/{menu_id}`
                .replace(`{${"menuId"}}`, encodeURIComponent(String(menuId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} roleId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleMenuByRoleId: async (roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling careworkerServiceGetRoleMenuByRoleId.');
            }
            const localVarPath = `/api/v1/roleMenus:byRoleId/{role_id}`
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetSmsLogById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetSmsLogById.');
            }
            const localVarPath = `/api/v1/smsLogs:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetSmsLogByTenantId: async (tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling careworkerServiceGetSmsLogByTenantId.');
            }
            const localVarPath = `/api/v1/smsLogs:byTenantId/{tenant_id}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetTenantById: async (id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling careworkerServiceGetTenantById.');
            }
            const localVarPath = `/api/v1/tenants:byId/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountDepartments: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accountDepartments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountPositions: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accountPositions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountRoles: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accountRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountSessions: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accountSessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccounts: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [parent] The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListBeds: async (parent?: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/beds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} parent The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListBedsWithDepartment: async (parent: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'parent' is not null or undefined
            if (parent === null || parent === undefined) {
                throw new RequiredError('parent','Required parameter parent was null or undefined when calling careworkerServiceListBedsWithDepartment.');
            }
            const localVarPath = `/api/v1/departments/{parent}/beds`
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListConfigs: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListCustomers: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListDepartments: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListDictDataSlice: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dictDataSlice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListDictTypes: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/dictTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListEmployees: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListFileCategroys: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/fileCategroys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListFiles: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListMenus: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/menus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListNoticeRecords: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/noticeRecords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListNoticeSettings: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/noticeSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListOperationLogs: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/operationLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListPositions: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListProjects: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRechargeOrders: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/rechargeOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRefundLogs: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/refundLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRefundRecords: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/refundRecords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRoleMenus: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/roleMenus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRoles: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListSmsLogs: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/smsLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListTenants: async (pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['pageToken'] = pageToken;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (view !== undefined) {
                localVarQueryParameter['view'] = view;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccount} account The Account resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccount: async (account: CareworkerAccount, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'account' is not null or undefined
            if (account === null || account === undefined) {
                throw new RequiredError('account','Required parameter account was null or undefined when calling careworkerServiceUpdateAccount.');
            }
            const localVarPath = `/api/v1/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof account !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(account !== undefined ? account : {})
                : (account || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountDepartment: async (accountDepartment: CareworkerAccountDepartment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountDepartment' is not null or undefined
            if (accountDepartment === null || accountDepartment === undefined) {
                throw new RequiredError('accountDepartment','Required parameter accountDepartment was null or undefined when calling careworkerServiceUpdateAccountDepartment.');
            }
            const localVarPath = `/api/v1/accountDepartments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountDepartment !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountDepartment !== undefined ? accountDepartment : {})
                : (accountDepartment || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountPosition: async (accountPosition: CareworkerAccountPosition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPosition' is not null or undefined
            if (accountPosition === null || accountPosition === undefined) {
                throw new RequiredError('accountPosition','Required parameter accountPosition was null or undefined when calling careworkerServiceUpdateAccountPosition.');
            }
            const localVarPath = `/api/v1/accountPositions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountPosition !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountPosition !== undefined ? accountPosition : {})
                : (accountPosition || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountRole} accountRole The AccountRole resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountRole: async (accountRole: CareworkerAccountRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountRole' is not null or undefined
            if (accountRole === null || accountRole === undefined) {
                throw new RequiredError('accountRole','Required parameter accountRole was null or undefined when calling careworkerServiceUpdateAccountRole.');
            }
            const localVarPath = `/api/v1/accountRoles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountRole !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountRole !== undefined ? accountRole : {})
                : (accountRole || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerAccountSession} accountSession The AccountSession resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountSession: async (accountSession: CareworkerAccountSession, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountSession' is not null or undefined
            if (accountSession === null || accountSession === undefined) {
                throw new RequiredError('accountSession','Required parameter accountSession was null or undefined when calling careworkerServiceUpdateAccountSession.');
            }
            const localVarPath = `/api/v1/accountSessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountSession !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountSession !== undefined ? accountSession : {})
                : (accountSession || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerBed} bed The Bed resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateBed: async (bed: CareworkerBed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bed' is not null or undefined
            if (bed === null || bed === undefined) {
                throw new RequiredError('bed','Required parameter bed was null or undefined when calling careworkerServiceUpdateBed.');
            }
            const localVarPath = `/api/v1/beds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof bed !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(bed !== undefined ? bed : {})
                : (bed || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerConfig} config The Config resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateConfig: async (config: CareworkerConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'config' is not null or undefined
            if (config === null || config === undefined) {
                throw new RequiredError('config','Required parameter config was null or undefined when calling careworkerServiceUpdateConfig.');
            }
            const localVarPath = `/api/v1/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof config !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(config !== undefined ? config : {})
                : (config || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerCustomer} customer The Customer resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateCustomer: async (customer: CareworkerCustomer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customer' is not null or undefined
            if (customer === null || customer === undefined) {
                throw new RequiredError('customer','Required parameter customer was null or undefined when calling careworkerServiceUpdateCustomer.');
            }
            const localVarPath = `/api/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof customer !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(customer !== undefined ? customer : {})
                : (customer || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerDepartment} department The Department resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateDepartment: async (department: CareworkerDepartment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'department' is not null or undefined
            if (department === null || department === undefined) {
                throw new RequiredError('department','Required parameter department was null or undefined when calling careworkerServiceUpdateDepartment.');
            }
            const localVarPath = `/api/v1/departments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof department !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(department !== undefined ? department : {})
                : (department || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerDictData} dictData The DictData resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateDictData: async (dictData: CareworkerDictData, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictData' is not null or undefined
            if (dictData === null || dictData === undefined) {
                throw new RequiredError('dictData','Required parameter dictData was null or undefined when calling careworkerServiceUpdateDictData.');
            }
            const localVarPath = `/api/v1/dictDataSlice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dictData !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dictData !== undefined ? dictData : {})
                : (dictData || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerDictType} dictType The DictType resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateDictType: async (dictType: CareworkerDictType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dictType' is not null or undefined
            if (dictType === null || dictType === undefined) {
                throw new RequiredError('dictType','Required parameter dictType was null or undefined when calling careworkerServiceUpdateDictType.');
            }
            const localVarPath = `/api/v1/dictTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof dictType !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(dictType !== undefined ? dictType : {})
                : (dictType || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerEmployee} employee The Employee resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateEmployee: async (employee: CareworkerEmployee, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'employee' is not null or undefined
            if (employee === null || employee === undefined) {
                throw new RequiredError('employee','Required parameter employee was null or undefined when calling careworkerServiceUpdateEmployee.');
            }
            const localVarPath = `/api/v1/employees`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof employee !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(employee !== undefined ? employee : {})
                : (employee || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerFile} file The File resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateFile: async (file: CareworkerFile, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling careworkerServiceUpdateFile.');
            }
            const localVarPath = `/api/v1/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof file !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(file !== undefined ? file : {})
                : (file || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateFileCategroy: async (fileCategroy: CareworkerFileCategroy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileCategroy' is not null or undefined
            if (fileCategroy === null || fileCategroy === undefined) {
                throw new RequiredError('fileCategroy','Required parameter fileCategroy was null or undefined when calling careworkerServiceUpdateFileCategroy.');
            }
            const localVarPath = `/api/v1/fileCategroys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof fileCategroy !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(fileCategroy !== undefined ? fileCategroy : {})
                : (fileCategroy || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerMenu} menu The Menu resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateMenu: async (menu: CareworkerMenu, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'menu' is not null or undefined
            if (menu === null || menu === undefined) {
                throw new RequiredError('menu','Required parameter menu was null or undefined when calling careworkerServiceUpdateMenu.');
            }
            const localVarPath = `/api/v1/menus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof menu !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(menu !== undefined ? menu : {})
                : (menu || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateNoticeRecord: async (noticeRecord: CareworkerNoticeRecord, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeRecord' is not null or undefined
            if (noticeRecord === null || noticeRecord === undefined) {
                throw new RequiredError('noticeRecord','Required parameter noticeRecord was null or undefined when calling careworkerServiceUpdateNoticeRecord.');
            }
            const localVarPath = `/api/v1/noticeRecords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof noticeRecord !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(noticeRecord !== undefined ? noticeRecord : {})
                : (noticeRecord || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateNoticeSetting: async (noticeSetting: CareworkerNoticeSetting, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'noticeSetting' is not null or undefined
            if (noticeSetting === null || noticeSetting === undefined) {
                throw new RequiredError('noticeSetting','Required parameter noticeSetting was null or undefined when calling careworkerServiceUpdateNoticeSetting.');
            }
            const localVarPath = `/api/v1/noticeSettings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof noticeSetting !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(noticeSetting !== undefined ? noticeSetting : {})
                : (noticeSetting || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerOperationLog} operationLog The OperationLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateOperationLog: async (operationLog: CareworkerOperationLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'operationLog' is not null or undefined
            if (operationLog === null || operationLog === undefined) {
                throw new RequiredError('operationLog','Required parameter operationLog was null or undefined when calling careworkerServiceUpdateOperationLog.');
            }
            const localVarPath = `/api/v1/operationLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof operationLog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(operationLog !== undefined ? operationLog : {})
                : (operationLog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerPosition} position The Position resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdatePosition: async (position: CareworkerPosition, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'position' is not null or undefined
            if (position === null || position === undefined) {
                throw new RequiredError('position','Required parameter position was null or undefined when calling careworkerServiceUpdatePosition.');
            }
            const localVarPath = `/api/v1/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof position !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(position !== undefined ? position : {})
                : (position || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerProject} project The Project resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateProject: async (project: CareworkerProject, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'project' is not null or undefined
            if (project === null || project === undefined) {
                throw new RequiredError('project','Required parameter project was null or undefined when calling careworkerServiceUpdateProject.');
            }
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof project !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(project !== undefined ? project : {})
                : (project || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRechargeOrder: async (rechargeOrder: CareworkerRechargeOrder, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rechargeOrder' is not null or undefined
            if (rechargeOrder === null || rechargeOrder === undefined) {
                throw new RequiredError('rechargeOrder','Required parameter rechargeOrder was null or undefined when calling careworkerServiceUpdateRechargeOrder.');
            }
            const localVarPath = `/api/v1/rechargeOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof rechargeOrder !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(rechargeOrder !== undefined ? rechargeOrder : {})
                : (rechargeOrder || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRefundLog} refundLog The RefundLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRefundLog: async (refundLog: CareworkerRefundLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundLog' is not null or undefined
            if (refundLog === null || refundLog === undefined) {
                throw new RequiredError('refundLog','Required parameter refundLog was null or undefined when calling careworkerServiceUpdateRefundLog.');
            }
            const localVarPath = `/api/v1/refundLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof refundLog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(refundLog !== undefined ? refundLog : {})
                : (refundLog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRefundRecord: async (refundRecord: CareworkerRefundRecord, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'refundRecord' is not null or undefined
            if (refundRecord === null || refundRecord === undefined) {
                throw new RequiredError('refundRecord','Required parameter refundRecord was null or undefined when calling careworkerServiceUpdateRefundRecord.');
            }
            const localVarPath = `/api/v1/refundRecords`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof refundRecord !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(refundRecord !== undefined ? refundRecord : {})
                : (refundRecord || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRole} role The Role resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRole: async (role: CareworkerRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'role' is not null or undefined
            if (role === null || role === undefined) {
                throw new RequiredError('role','Required parameter role was null or undefined when calling careworkerServiceUpdateRole.');
            }
            const localVarPath = `/api/v1/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof role !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(role !== undefined ? role : {})
                : (role || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRoleMenu: async (roleMenu: CareworkerRoleMenu, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleMenu' is not null or undefined
            if (roleMenu === null || roleMenu === undefined) {
                throw new RequiredError('roleMenu','Required parameter roleMenu was null or undefined when calling careworkerServiceUpdateRoleMenu.');
            }
            const localVarPath = `/api/v1/roleMenus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof roleMenu !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(roleMenu !== undefined ? roleMenu : {})
                : (roleMenu || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerSmsLog} smsLog The SmsLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateSmsLog: async (smsLog: CareworkerSmsLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'smsLog' is not null or undefined
            if (smsLog === null || smsLog === undefined) {
                throw new RequiredError('smsLog','Required parameter smsLog was null or undefined when calling careworkerServiceUpdateSmsLog.');
            }
            const localVarPath = `/api/v1/smsLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof smsLog !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(smsLog !== undefined ? smsLog : {})
                : (smsLog || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CareworkerTenant} tenant The Tenant resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateTenant: async (tenant: CareworkerTenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tenant' is not null or undefined
            if (tenant === null || tenant === undefined) {
                throw new RequiredError('tenant','Required parameter tenant was null or undefined when calling careworkerServiceUpdateTenant.');
            }
            const localVarPath = `/api/v1/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof tenant !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(tenant !== undefined ? tenant : {})
                : (tenant || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CareworkerServiceApi - functional programming interface
 * @export
 */
export const CareworkerServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CareworkerBatchCreateAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateAccountDepartments(body: CareworkerBatchCreateAccountDepartmentsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateAccountDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateAccountDepartments(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateAccountPositions(body: CareworkerBatchCreateAccountPositionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateAccountPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateAccountPositions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateAccountRoles(body: CareworkerBatchCreateAccountRolesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateAccountRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateAccountRoles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateAccountSessions(body: CareworkerBatchCreateAccountSessionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateAccountSessionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateAccountSessions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateAccounts(body: CareworkerBatchCreateAccountsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateAccountsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateAccounts(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateBeds(body: CareworkerBatchCreateBedsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateBedsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateBeds(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateConfigs(body: CareworkerBatchCreateConfigsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateConfigsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateConfigs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateCustomers(body: CareworkerBatchCreateCustomersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateCustomersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateCustomers(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateDepartments(body: CareworkerBatchCreateDepartmentsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateDepartments(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateDictDataSlice(body: CareworkerBatchCreateDictDataSliceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateDictDataSliceResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateDictDataSlice(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateDictTypes(body: CareworkerBatchCreateDictTypesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateDictTypesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateDictTypes(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateEmployees(body: CareworkerBatchCreateEmployeesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateEmployeesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateEmployees(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateFileCategroys(body: CareworkerBatchCreateFileCategroysRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateFileCategroysResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateFileCategroys(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateFiles(body: CareworkerBatchCreateFilesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateFilesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateFiles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateMenus(body: CareworkerBatchCreateMenusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateMenus(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateNoticeRecords(body: CareworkerBatchCreateNoticeRecordsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateNoticeRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateNoticeRecords(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateNoticeSettings(body: CareworkerBatchCreateNoticeSettingsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateNoticeSettingsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateNoticeSettings(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateOperationLogs(body: CareworkerBatchCreateOperationLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateOperationLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateOperationLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreatePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreatePositions(body: CareworkerBatchCreatePositionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreatePositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreatePositions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateProjects(body: CareworkerBatchCreateProjectsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateProjectsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateProjects(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateRechargeOrders(body: CareworkerBatchCreateRechargeOrdersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateRechargeOrdersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateRechargeOrders(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateRefundLogs(body: CareworkerBatchCreateRefundLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateRefundLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateRefundLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateRefundRecords(body: CareworkerBatchCreateRefundRecordsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateRefundRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateRefundRecords(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateRoleMenus(body: CareworkerBatchCreateRoleMenusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateRoleMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateRoleMenus(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateRoles(body: CareworkerBatchCreateRolesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateRoles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateSmsLogs(body: CareworkerBatchCreateSmsLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateSmsLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateSmsLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchCreateTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchCreateTenants(body: CareworkerBatchCreateTenantsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchCreateTenantsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchCreateTenants(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteAccountDepartments(body: CareworkerBatchDeleteAccountDepartmentsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteAccountDepartments(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteAccountPositions(body: CareworkerBatchDeleteAccountPositionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteAccountPositions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteAccountRoles(body: CareworkerBatchDeleteAccountRolesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteAccountRoles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteAccountSessions(body: CareworkerBatchDeleteAccountSessionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteAccountSessions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteAccounts(body: CareworkerBatchDeleteAccountsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteAccounts(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteBeds(body: CareworkerBatchDeleteBedsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteBeds(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteConfigs(body: CareworkerBatchDeleteConfigsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteConfigs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteCustomers(body: CareworkerBatchDeleteCustomersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteCustomers(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteDepartments(body: CareworkerBatchDeleteDepartmentsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteDepartments(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteDictDataSlice(body: CareworkerBatchDeleteDictDataSliceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteDictDataSlice(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteDictTypes(body: CareworkerBatchDeleteDictTypesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteDictTypes(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteEmployees(body: CareworkerBatchDeleteEmployeesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteEmployees(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteFileCategroys(body: CareworkerBatchDeleteFileCategroysRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteFileCategroys(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteFiles(body: CareworkerBatchDeleteFilesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteFiles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteMenus(body: CareworkerBatchDeleteMenusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteMenus(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteNoticeRecords(body: CareworkerBatchDeleteNoticeRecordsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteNoticeRecords(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteNoticeSettings(body: CareworkerBatchDeleteNoticeSettingsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteNoticeSettings(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteOperationLogs(body: CareworkerBatchDeleteOperationLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteOperationLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeletePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeletePositions(body: CareworkerBatchDeletePositionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeletePositions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteProjects(body: CareworkerBatchDeleteProjectsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteProjects(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteRechargeOrders(body: CareworkerBatchDeleteRechargeOrdersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteRechargeOrders(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteRefundLogs(body: CareworkerBatchDeleteRefundLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteRefundLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteRefundRecords(body: CareworkerBatchDeleteRefundRecordsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteRefundRecords(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteRoleMenus(body: CareworkerBatchDeleteRoleMenusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteRoleMenus(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteRoles(body: CareworkerBatchDeleteRolesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteRoles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteSmsLogs(body: CareworkerBatchDeleteSmsLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteSmsLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchDeleteTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchDeleteTenants(body: CareworkerBatchDeleteTenantsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchDeleteTenants(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountDepartmentsByAccountId(body: CareworkerBatchGetAccountDepartmentsByAccountIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountDepartmentsByAccountId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountDepartmentsByDepartmentId(body: CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountDepartmentsByDepartmentId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountDepartmentsById(body: CareworkerBatchGetAccountDepartmentsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountDepartmentsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountPositionsByAccountId(body: CareworkerBatchGetAccountPositionsByAccountIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountPositionsByAccountId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountPositionsById(body: CareworkerBatchGetAccountPositionsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountPositionsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByPositionIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountPositionsByPositionId(body: CareworkerBatchGetAccountPositionsByPositionIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountPositionsByPositionId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountRolesByAccountId(body: CareworkerBatchGetAccountRolesByAccountIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountRolesByAccountId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountRolesById(body: CareworkerBatchGetAccountRolesByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountRolesById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByRoleIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountRolesByRoleId(body: CareworkerBatchGetAccountRolesByRoleIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountRolesByRoleId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountSessionsByAccountId(body: CareworkerBatchGetAccountSessionsByAccountIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountSessionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountSessionsByAccountId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountSessionsById(body: CareworkerBatchGetAccountSessionsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountSessionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountSessionsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByTerminalRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountSessionsByTerminal(body: CareworkerBatchGetAccountSessionsByTerminalRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountSessionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountSessionsByTerminal(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountSessionsByToken(body: CareworkerBatchGetAccountSessionsByTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountSessionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountSessionsByToken(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountsById(body: CareworkerBatchGetAccountsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountsByName(body: CareworkerBatchGetAccountsByNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountsByName(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetAccountsByTenantId(body: CareworkerBatchGetAccountsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetAccountsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetAccountsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetBedsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetBedsById(body: CareworkerBatchGetBedsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetBedsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetBedsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetBedsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetBedsByTenantId(body: CareworkerBatchGetBedsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetBedsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetBedsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetConfigsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetConfigsById(body: CareworkerBatchGetConfigsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetConfigsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetConfigsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetConfigsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetConfigsByTenantId(body: CareworkerBatchGetConfigsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetConfigsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetConfigsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetCustomersById(body: CareworkerBatchGetCustomersByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetCustomersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetCustomersById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetCustomersByName(body: CareworkerBatchGetCustomersByNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetCustomersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetCustomersByName(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersBySnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetCustomersBySn(body: CareworkerBatchGetCustomersBySnRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetCustomersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetCustomersBySn(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetCustomersByTenantId(body: CareworkerBatchGetCustomersByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetCustomersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetCustomersByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetDepartmentsById(body: CareworkerBatchGetDepartmentsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetDepartmentsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByProjectIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetDepartmentsByProjectId(body: CareworkerBatchGetDepartmentsByProjectIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetDepartmentsByProjectId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetDepartmentsByTenantId(body: CareworkerBatchGetDepartmentsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetDepartmentsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDictDataSliceByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetDictDataSliceById(body: CareworkerBatchGetDictDataSliceByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetDictDataSliceResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetDictDataSliceById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetDictTypesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetDictTypesById(body: CareworkerBatchGetDictTypesByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetDictTypesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetDictTypesById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetEmployeesById(body: CareworkerBatchGetEmployeesByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetEmployeesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetEmployeesById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetEmployeesByName(body: CareworkerBatchGetEmployeesByNameRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetEmployeesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetEmployeesByName(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetEmployeesByTenantId(body: CareworkerBatchGetEmployeesByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetEmployeesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetEmployeesByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFileCategroysByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetFileCategroysById(body: CareworkerBatchGetFileCategroysByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetFileCategroysResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetFileCategroysById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFileCategroysByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetFileCategroysByTenantId(body: CareworkerBatchGetFileCategroysByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetFileCategroysResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetFileCategroysByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFilesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetFilesById(body: CareworkerBatchGetFilesByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetFilesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetFilesById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetFilesByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetFilesByTenantId(body: CareworkerBatchGetFilesByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetFilesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetFilesByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetMenusByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetMenusById(body: CareworkerBatchGetMenusByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetMenusById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByEmployeeIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetNoticeRecordsByEmployeeId(body: CareworkerBatchGetNoticeRecordsByEmployeeIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetNoticeRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetNoticeRecordsByEmployeeId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetNoticeRecordsById(body: CareworkerBatchGetNoticeRecordsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetNoticeRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetNoticeRecordsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetNoticeRecordsByTenantId(body: CareworkerBatchGetNoticeRecordsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetNoticeRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetNoticeRecordsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeSettingsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetNoticeSettingsById(body: CareworkerBatchGetNoticeSettingsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetNoticeSettingsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetNoticeSettingsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeSettingsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetNoticeSettingsByTenantId(body: CareworkerBatchGetNoticeSettingsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetNoticeSettingsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetNoticeSettingsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetOperationLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetOperationLogsById(body: CareworkerBatchGetOperationLogsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetOperationLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetOperationLogsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetPositionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetPositionsById(body: CareworkerBatchGetPositionsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetPositionsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetPositionsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetPositionsByTenantId(body: CareworkerBatchGetPositionsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetPositionsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetProjectsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetProjectsById(body: CareworkerBatchGetProjectsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetProjectsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetProjectsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetProjectsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetProjectsByTenantId(body: CareworkerBatchGetProjectsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetProjectsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetProjectsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRechargeOrdersByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRechargeOrdersById(body: CareworkerBatchGetRechargeOrdersByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRechargeOrdersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRechargeOrdersById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRechargeOrdersByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRechargeOrdersByTenantId(body: CareworkerBatchGetRechargeOrdersByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRechargeOrdersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRechargeOrdersByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRefundLogsById(body: CareworkerBatchGetRefundLogsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRefundLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRefundLogsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundLogsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRefundLogsByTenantId(body: CareworkerBatchGetRefundLogsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRefundLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRefundLogsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundRecordsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRefundRecordsById(body: CareworkerBatchGetRefundRecordsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRefundRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRefundRecordsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundRecordsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRefundRecordsByTenantId(body: CareworkerBatchGetRefundRecordsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRefundRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRefundRecordsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRoleMenusById(body: CareworkerBatchGetRoleMenusByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRoleMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRoleMenusById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByMenuIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRoleMenusByMenuId(body: CareworkerBatchGetRoleMenusByMenuIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRoleMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRoleMenusByMenuId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByRoleIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRoleMenusByRoleId(body: CareworkerBatchGetRoleMenusByRoleIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRoleMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRoleMenusByRoleId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetRolesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetRolesById(body: CareworkerBatchGetRolesByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetRolesById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetSmsLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetSmsLogsById(body: CareworkerBatchGetSmsLogsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetSmsLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetSmsLogsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetSmsLogsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetSmsLogsByTenantId(body: CareworkerBatchGetSmsLogsByTenantIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetSmsLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetSmsLogsByTenantId(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchGetTenantsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchGetTenantsById(body: CareworkerBatchGetTenantsByIdRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchGetTenantsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchGetTenantsById(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateAccountDepartments(body: CareworkerBatchUpdateAccountDepartmentsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateAccountDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateAccountDepartments(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateAccountPositions(body: CareworkerBatchUpdateAccountPositionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateAccountPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateAccountPositions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateAccountRoles(body: CareworkerBatchUpdateAccountRolesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateAccountRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateAccountRoles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateAccountSessions(body: CareworkerBatchUpdateAccountSessionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateAccountSessionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateAccountSessions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateAccounts(body: CareworkerBatchUpdateAccountsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateAccountsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateAccounts(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateBeds(body: CareworkerBatchUpdateBedsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateBedsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateBeds(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateConfigs(body: CareworkerBatchUpdateConfigsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateConfigsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateConfigs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateCustomers(body: CareworkerBatchUpdateCustomersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateCustomersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateCustomers(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateDepartments(body: CareworkerBatchUpdateDepartmentsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateDepartments(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateDictDataSlice(body: CareworkerBatchUpdateDictDataSliceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateDictDataSliceResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateDictDataSlice(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateDictTypes(body: CareworkerBatchUpdateDictTypesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateDictTypesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateDictTypes(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateEmployees(body: CareworkerBatchUpdateEmployeesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateEmployeesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateEmployees(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateFileCategroys(body: CareworkerBatchUpdateFileCategroysRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateFileCategroysResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateFileCategroys(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateFiles(body: CareworkerBatchUpdateFilesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateFilesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateFiles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateMenus(body: CareworkerBatchUpdateMenusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateMenus(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateNoticeRecords(body: CareworkerBatchUpdateNoticeRecordsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateNoticeRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateNoticeRecords(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateNoticeSettings(body: CareworkerBatchUpdateNoticeSettingsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateNoticeSettingsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateNoticeSettings(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateOperationLogs(body: CareworkerBatchUpdateOperationLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateOperationLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateOperationLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdatePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdatePositions(body: CareworkerBatchUpdatePositionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdatePositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdatePositions(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateProjects(body: CareworkerBatchUpdateProjectsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateProjectsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateProjects(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateRechargeOrders(body: CareworkerBatchUpdateRechargeOrdersRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateRechargeOrdersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateRechargeOrders(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateRefundLogs(body: CareworkerBatchUpdateRefundLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateRefundLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateRefundLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateRefundRecords(body: CareworkerBatchUpdateRefundRecordsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateRefundRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateRefundRecords(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateRoleMenus(body: CareworkerBatchUpdateRoleMenusRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateRoleMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateRoleMenus(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateRoles(body: CareworkerBatchUpdateRolesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateRoles(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateSmsLogs(body: CareworkerBatchUpdateSmsLogsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateSmsLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateSmsLogs(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBatchUpdateTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceBatchUpdateTenants(body: CareworkerBatchUpdateTenantsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBatchUpdateTenantsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceBatchUpdateTenants(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccount} account The Account resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Account is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateAccount(account: CareworkerAccount, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccount>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateAccount(account, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountDepartment is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateAccountDepartment(accountDepartment: CareworkerAccountDepartment, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateAccountDepartment(accountDepartment, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountPosition is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateAccountPosition(accountPosition: CareworkerAccountPosition, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateAccountPosition(accountPosition, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountRole} accountRole The AccountRole resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountRole is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateAccountRole(accountRole: CareworkerAccountRole, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateAccountRole(accountRole, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountSession} accountSession The AccountSession resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountSession is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateAccountSession(accountSession: CareworkerAccountSession, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountSession>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateAccountSession(accountSession, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBed} bed The Bed resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Bed is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateBed(bed: CareworkerBed, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBed>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateBed(bed, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerConfig} config The Config resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Config is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateConfig(config: CareworkerConfig, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerConfig>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateConfig(config, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerCustomer} customer The Customer resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Customer is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateCustomer(customer: CareworkerCustomer, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerCustomer>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateCustomer(customer, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerDepartment} department The Department resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Department is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateDepartment(department: CareworkerDepartment, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateDepartment(department, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerDictData} dictData The DictData resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the DictData is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateDictData(dictData: CareworkerDictData, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDictData>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateDictData(dictData, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerDictType} dictType The DictType resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the DictType is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateDictType(dictType: CareworkerDictType, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDictType>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateDictType(dictType, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerEmployee} employee The Employee resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Employee is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateEmployee(employee: CareworkerEmployee, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerEmployee>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateEmployee(employee, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerFile} file The File resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the File is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateFile(file: CareworkerFile, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFile>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateFile(file, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the FileCategroy is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateFileCategroy(fileCategroy: CareworkerFileCategroy, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFileCategroy>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateFileCategroy(fileCategroy, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerMenu} menu The Menu resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Menu is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateMenu(menu: CareworkerMenu, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateMenu(menu, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the NoticeRecord is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateNoticeRecord(noticeRecord: CareworkerNoticeRecord, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateNoticeRecord(noticeRecord, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the NoticeSetting is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateNoticeSetting(noticeSetting: CareworkerNoticeSetting, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeSetting>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateNoticeSetting(noticeSetting, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerOperationLog} operationLog The OperationLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the OperationLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateOperationLog(operationLog: CareworkerOperationLog, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerOperationLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateOperationLog(operationLog, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerPosition} position The Position resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Position is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreatePosition(position: CareworkerPosition, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreatePosition(position, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerProject} project The Project resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Project is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateProject(project: CareworkerProject, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerProject>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateProject(project, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RechargeOrder is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateRechargeOrder(rechargeOrder: CareworkerRechargeOrder, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRechargeOrder>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateRechargeOrder(rechargeOrder, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRefundLog} refundLog The RefundLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RefundLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateRefundLog(refundLog: CareworkerRefundLog, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateRefundLog(refundLog, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RefundRecord is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateRefundRecord(refundRecord: CareworkerRefundRecord, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateRefundRecord(refundRecord, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRole} role The Role resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Role is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateRole(role: CareworkerRole, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateRole(role, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RoleMenu is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateRoleMenu(roleMenu: CareworkerRoleMenu, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRoleMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateRoleMenu(roleMenu, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerSmsLog} smsLog The SmsLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the SmsLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateSmsLog(smsLog: CareworkerSmsLog, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerSmsLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateSmsLog(smsLog, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerTenant} tenant The Tenant resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Tenant is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceCreateTenant(tenant: CareworkerTenant, parent?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerTenant>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceCreateTenant(tenant, parent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Account to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteAccount(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteAccount(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountDepartment to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteAccountDepartment(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteAccountDepartment(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountPosition to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteAccountPosition(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteAccountPosition(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountRole to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteAccountRole(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteAccountRole(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the AccountSession to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteAccountSession(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteAccountSession(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Bed to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteBed(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteBed(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Config to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteConfig(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteConfig(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Customer to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteCustomer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteCustomer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Department to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteDepartment(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteDepartment(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the DictData to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteDictData(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteDictData(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the DictType to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteDictType(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteDictType(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Employee to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteEmployee(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteEmployee(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the File to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteFile(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteFile(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the FileCategroy to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteFileCategroy(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteFileCategroy(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Menu to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteMenu(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteMenu(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the NoticeRecord to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteNoticeRecord(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteNoticeRecord(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the NoticeSetting to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteNoticeSetting(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteNoticeSetting(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the OperationLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteOperationLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteOperationLog(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Position to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeletePosition(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeletePosition(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Project to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteProject(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteProject(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RechargeOrder to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteRechargeOrder(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteRechargeOrder(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RefundLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteRefundLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteRefundLog(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RefundRecord to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteRefundRecord(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteRefundRecord(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Role to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteRole(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteRole(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the RoleMenu to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteRoleMenu(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteRoleMenu(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the SmsLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteSmsLog(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteSmsLog(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The resource id of the Tenant to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceDeleteTenant(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceDeleteTenant(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccount>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccount>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountByName(name, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccount>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountDepartmentByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountDepartmentByAccountId(accountId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} departmentId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountDepartmentByDepartmentId(departmentId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountDepartmentByDepartmentId(departmentId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountDepartmentById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountDepartmentById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountPositionByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountPositionByAccountId(accountId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountPositionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountPositionById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} positionId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountPositionByPositionId(positionId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountPositionByPositionId(positionId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountRoleByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountRoleByAccountId(accountId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountRoleById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountRoleById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} roleId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountRoleByRoleId(roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountRoleByRoleId(roleId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountSessionByAccountId(accountId: number, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountSession>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountSessionByAccountId(accountId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountSessionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountSession>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountSessionById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} terminal The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountSessionByTerminal(terminal: boolean, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountSession>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountSessionByTerminal(terminal, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} token The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetAccountSessionByToken(token: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountSession>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetAccountSessionByToken(token, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetBedById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBed>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetBedById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetBedByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBed>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetBedByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetConfigById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerConfig>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetConfigById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetConfigByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerConfig>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetConfigByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetCustomerById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerCustomer>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetCustomerById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetCustomerByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerCustomer>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetCustomerByName(name, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} sn The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetCustomerBySn(sn: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerCustomer>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetCustomerBySn(sn, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetCustomerByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerCustomer>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetCustomerByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetDepartmentById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetDepartmentById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} projectId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetDepartmentByProjectId(projectId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetDepartmentByProjectId(projectId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetDepartmentByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetDepartmentByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetDictDataById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDictData>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetDictDataById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetDictTypeById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDictType>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetDictTypeById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetEmployeeById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerEmployee>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetEmployeeById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetEmployeeByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerEmployee>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetEmployeeByName(name, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetEmployeeByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerEmployee>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetEmployeeByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetFileById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFile>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetFileById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetFileByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFile>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetFileByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetFileCategroyById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFileCategroy>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetFileCategroyById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetFileCategroyByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFileCategroy>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetFileCategroyByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetMenuById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetMenuById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} employeeId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetNoticeRecordByEmployeeId(employeeId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetNoticeRecordByEmployeeId(employeeId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetNoticeRecordById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetNoticeRecordById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetNoticeRecordByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetNoticeRecordByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetNoticeSettingById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeSetting>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetNoticeSettingById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetNoticeSettingByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeSetting>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetNoticeSettingByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetOperationLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerOperationLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetOperationLogById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetPositionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetPositionById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetPositionByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetPositionByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetProjectById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerProject>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetProjectById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetProjectByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerProject>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetProjectByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRechargeOrderById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRechargeOrder>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRechargeOrderById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRechargeOrderByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRechargeOrder>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRechargeOrderByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRefundLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRefundLogById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRefundLogByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRefundLogByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRefundRecordById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRefundRecordById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRefundRecordByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRefundRecordByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRoleById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRoleById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRoleMenuById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRoleMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRoleMenuById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} menuId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRoleMenuByMenuId(menuId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRoleMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRoleMenuByMenuId(menuId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} roleId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetRoleMenuByRoleId(roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRoleMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetRoleMenuByRoleId(roleId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetSmsLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerSmsLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetSmsLogById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetSmsLogByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerSmsLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetSmsLogByTenantId(tenantId, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceGetTenantById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerTenant>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceGetTenantById(id, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListAccountDepartments(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListAccountDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListAccountDepartments(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListAccountPositions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListAccountPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListAccountPositions(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListAccountRoles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListAccountRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListAccountRoles(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListAccountSessions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListAccountSessionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListAccountSessions(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListAccounts(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListAccountsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListAccounts(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [parent] The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListBeds(parent?: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListBedsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListBeds(parent, pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} parent The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListBedsWithDepartment(parent: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListBedsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListBedsWithDepartment(parent, pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListConfigs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListConfigsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListConfigs(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListCustomers(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListCustomersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListCustomers(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListDepartments(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListDepartmentsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListDepartments(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListDictDataSlice(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListDictDataSliceResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListDictDataSlice(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListDictTypes(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListDictTypesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListDictTypes(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListEmployees(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListEmployeesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListEmployees(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListFileCategroys(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListFileCategroysResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListFileCategroys(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListFiles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListFilesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListFiles(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListMenus(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListMenus(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListNoticeRecords(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListNoticeRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListNoticeRecords(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListNoticeSettings(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListNoticeSettingsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListNoticeSettings(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListOperationLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListOperationLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListOperationLogs(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListPositions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListPositionsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListPositions(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListProjects(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListProjectsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListProjects(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListRechargeOrders(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListRechargeOrdersResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListRechargeOrders(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListRefundLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListRefundLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListRefundLogs(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListRefundRecords(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListRefundRecordsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListRefundRecords(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListRoleMenus(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListRoleMenusResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListRoleMenus(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListRoles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListRolesResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListRoles(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListSmsLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListSmsLogsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListSmsLogs(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceListTenants(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerListTenantsResponse>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceListTenants(pageSize, pageToken, filter, orderBy, view, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccount} account The Account resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateAccount(account: CareworkerAccount, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccount>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateAccount(account, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateAccountDepartment(accountDepartment: CareworkerAccountDepartment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateAccountDepartment(accountDepartment, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateAccountPosition(accountPosition: CareworkerAccountPosition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateAccountPosition(accountPosition, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountRole} accountRole The AccountRole resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateAccountRole(accountRole: CareworkerAccountRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateAccountRole(accountRole, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerAccountSession} accountSession The AccountSession resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateAccountSession(accountSession: CareworkerAccountSession, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerAccountSession>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateAccountSession(accountSession, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerBed} bed The Bed resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateBed(bed: CareworkerBed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerBed>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateBed(bed, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerConfig} config The Config resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateConfig(config: CareworkerConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerConfig>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateConfig(config, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerCustomer} customer The Customer resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateCustomer(customer: CareworkerCustomer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerCustomer>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateCustomer(customer, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerDepartment} department The Department resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateDepartment(department: CareworkerDepartment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDepartment>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateDepartment(department, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerDictData} dictData The DictData resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateDictData(dictData: CareworkerDictData, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDictData>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateDictData(dictData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerDictType} dictType The DictType resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateDictType(dictType: CareworkerDictType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerDictType>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateDictType(dictType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerEmployee} employee The Employee resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateEmployee(employee: CareworkerEmployee, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerEmployee>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateEmployee(employee, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerFile} file The File resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateFile(file: CareworkerFile, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFile>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateFile(file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateFileCategroy(fileCategroy: CareworkerFileCategroy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerFileCategroy>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateFileCategroy(fileCategroy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerMenu} menu The Menu resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateMenu(menu: CareworkerMenu, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateMenu(menu, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateNoticeRecord(noticeRecord: CareworkerNoticeRecord, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateNoticeRecord(noticeRecord, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateNoticeSetting(noticeSetting: CareworkerNoticeSetting, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerNoticeSetting>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateNoticeSetting(noticeSetting, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerOperationLog} operationLog The OperationLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateOperationLog(operationLog: CareworkerOperationLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerOperationLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateOperationLog(operationLog, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerPosition} position The Position resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdatePosition(position: CareworkerPosition, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerPosition>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdatePosition(position, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerProject} project The Project resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateProject(project: CareworkerProject, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerProject>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateProject(project, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateRechargeOrder(rechargeOrder: CareworkerRechargeOrder, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRechargeOrder>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateRechargeOrder(rechargeOrder, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRefundLog} refundLog The RefundLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateRefundLog(refundLog: CareworkerRefundLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateRefundLog(refundLog, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateRefundRecord(refundRecord: CareworkerRefundRecord, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRefundRecord>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateRefundRecord(refundRecord, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRole} role The Role resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateRole(role: CareworkerRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRole>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateRole(role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateRoleMenu(roleMenu: CareworkerRoleMenu, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerRoleMenu>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateRoleMenu(roleMenu, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerSmsLog} smsLog The SmsLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateSmsLog(smsLog: CareworkerSmsLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerSmsLog>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateSmsLog(smsLog, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {CareworkerTenant} tenant The Tenant resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async careworkerServiceUpdateTenant(tenant: CareworkerTenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CareworkerTenant>> {
            const localVarAxiosArgs = await CareworkerServiceApiAxiosParamCreator(configuration).careworkerServiceUpdateTenant(tenant, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CareworkerServiceApi - factory interface
 * @export
 */
export const CareworkerServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CareworkerBatchCreateAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountDepartments(body: CareworkerBatchCreateAccountDepartmentsRequest, options?: any): AxiosPromise<CareworkerBatchCreateAccountDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateAccountDepartments(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountPositions(body: CareworkerBatchCreateAccountPositionsRequest, options?: any): AxiosPromise<CareworkerBatchCreateAccountPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateAccountPositions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountRoles(body: CareworkerBatchCreateAccountRolesRequest, options?: any): AxiosPromise<CareworkerBatchCreateAccountRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateAccountRoles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccountSessions(body: CareworkerBatchCreateAccountSessionsRequest, options?: any): AxiosPromise<CareworkerBatchCreateAccountSessionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateAccountSessions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateAccounts(body: CareworkerBatchCreateAccountsRequest, options?: any): AxiosPromise<CareworkerBatchCreateAccountsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateAccounts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateBeds(body: CareworkerBatchCreateBedsRequest, options?: any): AxiosPromise<CareworkerBatchCreateBedsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateBeds(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateConfigs(body: CareworkerBatchCreateConfigsRequest, options?: any): AxiosPromise<CareworkerBatchCreateConfigsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateConfigs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateCustomers(body: CareworkerBatchCreateCustomersRequest, options?: any): AxiosPromise<CareworkerBatchCreateCustomersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateCustomers(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateDepartments(body: CareworkerBatchCreateDepartmentsRequest, options?: any): AxiosPromise<CareworkerBatchCreateDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateDepartments(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateDictDataSlice(body: CareworkerBatchCreateDictDataSliceRequest, options?: any): AxiosPromise<CareworkerBatchCreateDictDataSliceResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateDictDataSlice(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateDictTypes(body: CareworkerBatchCreateDictTypesRequest, options?: any): AxiosPromise<CareworkerBatchCreateDictTypesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateDictTypes(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateEmployees(body: CareworkerBatchCreateEmployeesRequest, options?: any): AxiosPromise<CareworkerBatchCreateEmployeesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateEmployees(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateFileCategroys(body: CareworkerBatchCreateFileCategroysRequest, options?: any): AxiosPromise<CareworkerBatchCreateFileCategroysResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateFileCategroys(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateFiles(body: CareworkerBatchCreateFilesRequest, options?: any): AxiosPromise<CareworkerBatchCreateFilesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateFiles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateMenus(body: CareworkerBatchCreateMenusRequest, options?: any): AxiosPromise<CareworkerBatchCreateMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateMenus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateNoticeRecords(body: CareworkerBatchCreateNoticeRecordsRequest, options?: any): AxiosPromise<CareworkerBatchCreateNoticeRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateNoticeRecords(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateNoticeSettings(body: CareworkerBatchCreateNoticeSettingsRequest, options?: any): AxiosPromise<CareworkerBatchCreateNoticeSettingsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateNoticeSettings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateOperationLogs(body: CareworkerBatchCreateOperationLogsRequest, options?: any): AxiosPromise<CareworkerBatchCreateOperationLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateOperationLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreatePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreatePositions(body: CareworkerBatchCreatePositionsRequest, options?: any): AxiosPromise<CareworkerBatchCreatePositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreatePositions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateProjects(body: CareworkerBatchCreateProjectsRequest, options?: any): AxiosPromise<CareworkerBatchCreateProjectsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateProjects(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRechargeOrders(body: CareworkerBatchCreateRechargeOrdersRequest, options?: any): AxiosPromise<CareworkerBatchCreateRechargeOrdersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateRechargeOrders(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRefundLogs(body: CareworkerBatchCreateRefundLogsRequest, options?: any): AxiosPromise<CareworkerBatchCreateRefundLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateRefundLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRefundRecords(body: CareworkerBatchCreateRefundRecordsRequest, options?: any): AxiosPromise<CareworkerBatchCreateRefundRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateRefundRecords(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRoleMenus(body: CareworkerBatchCreateRoleMenusRequest, options?: any): AxiosPromise<CareworkerBatchCreateRoleMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateRoleMenus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateRoles(body: CareworkerBatchCreateRolesRequest, options?: any): AxiosPromise<CareworkerBatchCreateRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateRoles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateSmsLogs(body: CareworkerBatchCreateSmsLogsRequest, options?: any): AxiosPromise<CareworkerBatchCreateSmsLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateSmsLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchCreateTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchCreateTenants(body: CareworkerBatchCreateTenantsRequest, options?: any): AxiosPromise<CareworkerBatchCreateTenantsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchCreateTenants(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountDepartments(body: CareworkerBatchDeleteAccountDepartmentsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteAccountDepartments(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountPositions(body: CareworkerBatchDeleteAccountPositionsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteAccountPositions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountRoles(body: CareworkerBatchDeleteAccountRolesRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteAccountRoles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccountSessions(body: CareworkerBatchDeleteAccountSessionsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteAccountSessions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteAccounts(body: CareworkerBatchDeleteAccountsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteAccounts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteBeds(body: CareworkerBatchDeleteBedsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteBeds(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteConfigs(body: CareworkerBatchDeleteConfigsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteConfigs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteCustomers(body: CareworkerBatchDeleteCustomersRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteCustomers(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteDepartments(body: CareworkerBatchDeleteDepartmentsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteDepartments(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteDictDataSlice(body: CareworkerBatchDeleteDictDataSliceRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteDictDataSlice(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteDictTypes(body: CareworkerBatchDeleteDictTypesRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteDictTypes(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteEmployees(body: CareworkerBatchDeleteEmployeesRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteEmployees(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteFileCategroys(body: CareworkerBatchDeleteFileCategroysRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteFileCategroys(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteFiles(body: CareworkerBatchDeleteFilesRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteFiles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteMenus(body: CareworkerBatchDeleteMenusRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteMenus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteNoticeRecords(body: CareworkerBatchDeleteNoticeRecordsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteNoticeRecords(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteNoticeSettings(body: CareworkerBatchDeleteNoticeSettingsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteNoticeSettings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteOperationLogs(body: CareworkerBatchDeleteOperationLogsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteOperationLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeletePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeletePositions(body: CareworkerBatchDeletePositionsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeletePositions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteProjects(body: CareworkerBatchDeleteProjectsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteProjects(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRechargeOrders(body: CareworkerBatchDeleteRechargeOrdersRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteRechargeOrders(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRefundLogs(body: CareworkerBatchDeleteRefundLogsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteRefundLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRefundRecords(body: CareworkerBatchDeleteRefundRecordsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteRefundRecords(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRoleMenus(body: CareworkerBatchDeleteRoleMenusRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteRoleMenus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteRoles(body: CareworkerBatchDeleteRolesRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteRoles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteSmsLogs(body: CareworkerBatchDeleteSmsLogsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteSmsLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchDeleteTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchDeleteTenants(body: CareworkerBatchDeleteTenantsRequest, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchDeleteTenants(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountDepartmentsByAccountId(body: CareworkerBatchGetAccountDepartmentsByAccountIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountDepartmentsByAccountId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountDepartmentsByDepartmentId(body: CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountDepartmentsByDepartmentId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountDepartmentsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountDepartmentsById(body: CareworkerBatchGetAccountDepartmentsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountDepartmentsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountPositionsByAccountId(body: CareworkerBatchGetAccountPositionsByAccountIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountPositionsByAccountId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountPositionsById(body: CareworkerBatchGetAccountPositionsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountPositionsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountPositionsByPositionIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountPositionsByPositionId(body: CareworkerBatchGetAccountPositionsByPositionIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountPositionsByPositionId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountRolesByAccountId(body: CareworkerBatchGetAccountRolesByAccountIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountRolesByAccountId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountRolesById(body: CareworkerBatchGetAccountRolesByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountRolesById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountRolesByRoleIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountRolesByRoleId(body: CareworkerBatchGetAccountRolesByRoleIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountRolesByRoleId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByAccountIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsByAccountId(body: CareworkerBatchGetAccountSessionsByAccountIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountSessionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountSessionsByAccountId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsById(body: CareworkerBatchGetAccountSessionsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountSessionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountSessionsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByTerminalRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsByTerminal(body: CareworkerBatchGetAccountSessionsByTerminalRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountSessionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountSessionsByTerminal(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountSessionsByTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountSessionsByToken(body: CareworkerBatchGetAccountSessionsByTokenRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountSessionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountSessionsByToken(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountsById(body: CareworkerBatchGetAccountsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountsByName(body: CareworkerBatchGetAccountsByNameRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountsByName(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetAccountsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetAccountsByTenantId(body: CareworkerBatchGetAccountsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetAccountsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetAccountsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetBedsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetBedsById(body: CareworkerBatchGetBedsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetBedsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetBedsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetBedsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetBedsByTenantId(body: CareworkerBatchGetBedsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetBedsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetBedsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetConfigsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetConfigsById(body: CareworkerBatchGetConfigsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetConfigsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetConfigsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetConfigsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetConfigsByTenantId(body: CareworkerBatchGetConfigsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetConfigsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetConfigsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersById(body: CareworkerBatchGetCustomersByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetCustomersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetCustomersById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersByName(body: CareworkerBatchGetCustomersByNameRequest, options?: any): AxiosPromise<CareworkerBatchGetCustomersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetCustomersByName(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersBySnRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersBySn(body: CareworkerBatchGetCustomersBySnRequest, options?: any): AxiosPromise<CareworkerBatchGetCustomersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetCustomersBySn(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetCustomersByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetCustomersByTenantId(body: CareworkerBatchGetCustomersByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetCustomersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetCustomersByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDepartmentsById(body: CareworkerBatchGetDepartmentsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetDepartmentsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByProjectIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDepartmentsByProjectId(body: CareworkerBatchGetDepartmentsByProjectIdRequest, options?: any): AxiosPromise<CareworkerBatchGetDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetDepartmentsByProjectId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetDepartmentsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDepartmentsByTenantId(body: CareworkerBatchGetDepartmentsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetDepartmentsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetDictDataSliceByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDictDataSliceById(body: CareworkerBatchGetDictDataSliceByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetDictDataSliceResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetDictDataSliceById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetDictTypesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetDictTypesById(body: CareworkerBatchGetDictTypesByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetDictTypesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetDictTypesById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetEmployeesById(body: CareworkerBatchGetEmployeesByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetEmployeesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetEmployeesById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByNameRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetEmployeesByName(body: CareworkerBatchGetEmployeesByNameRequest, options?: any): AxiosPromise<CareworkerBatchGetEmployeesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetEmployeesByName(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetEmployeesByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetEmployeesByTenantId(body: CareworkerBatchGetEmployeesByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetEmployeesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetEmployeesByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetFileCategroysByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFileCategroysById(body: CareworkerBatchGetFileCategroysByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetFileCategroysResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetFileCategroysById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetFileCategroysByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFileCategroysByTenantId(body: CareworkerBatchGetFileCategroysByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetFileCategroysResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetFileCategroysByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetFilesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFilesById(body: CareworkerBatchGetFilesByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetFilesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetFilesById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetFilesByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetFilesByTenantId(body: CareworkerBatchGetFilesByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetFilesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetFilesByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetMenusByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetMenusById(body: CareworkerBatchGetMenusByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetMenusById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByEmployeeIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeRecordsByEmployeeId(body: CareworkerBatchGetNoticeRecordsByEmployeeIdRequest, options?: any): AxiosPromise<CareworkerBatchGetNoticeRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetNoticeRecordsByEmployeeId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeRecordsById(body: CareworkerBatchGetNoticeRecordsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetNoticeRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetNoticeRecordsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeRecordsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeRecordsByTenantId(body: CareworkerBatchGetNoticeRecordsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetNoticeRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetNoticeRecordsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeSettingsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeSettingsById(body: CareworkerBatchGetNoticeSettingsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetNoticeSettingsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetNoticeSettingsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetNoticeSettingsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetNoticeSettingsByTenantId(body: CareworkerBatchGetNoticeSettingsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetNoticeSettingsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetNoticeSettingsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetOperationLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetOperationLogsById(body: CareworkerBatchGetOperationLogsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetOperationLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetOperationLogsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetPositionsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetPositionsById(body: CareworkerBatchGetPositionsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetPositionsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetPositionsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetPositionsByTenantId(body: CareworkerBatchGetPositionsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetPositionsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetProjectsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetProjectsById(body: CareworkerBatchGetProjectsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetProjectsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetProjectsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetProjectsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetProjectsByTenantId(body: CareworkerBatchGetProjectsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetProjectsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetProjectsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRechargeOrdersByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRechargeOrdersById(body: CareworkerBatchGetRechargeOrdersByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRechargeOrdersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRechargeOrdersById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRechargeOrdersByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRechargeOrdersByTenantId(body: CareworkerBatchGetRechargeOrdersByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRechargeOrdersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRechargeOrdersByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundLogsById(body: CareworkerBatchGetRefundLogsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRefundLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRefundLogsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundLogsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundLogsByTenantId(body: CareworkerBatchGetRefundLogsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRefundLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRefundLogsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundRecordsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundRecordsById(body: CareworkerBatchGetRefundRecordsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRefundRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRefundRecordsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRefundRecordsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRefundRecordsByTenantId(body: CareworkerBatchGetRefundRecordsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRefundRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRefundRecordsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRoleMenusById(body: CareworkerBatchGetRoleMenusByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRoleMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRoleMenusById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByMenuIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRoleMenusByMenuId(body: CareworkerBatchGetRoleMenusByMenuIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRoleMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRoleMenusByMenuId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRoleMenusByRoleIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRoleMenusByRoleId(body: CareworkerBatchGetRoleMenusByRoleIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRoleMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRoleMenusByRoleId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetRolesByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetRolesById(body: CareworkerBatchGetRolesByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetRolesById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetSmsLogsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetSmsLogsById(body: CareworkerBatchGetSmsLogsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetSmsLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetSmsLogsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetSmsLogsByTenantIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetSmsLogsByTenantId(body: CareworkerBatchGetSmsLogsByTenantIdRequest, options?: any): AxiosPromise<CareworkerBatchGetSmsLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetSmsLogsByTenantId(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchGetTenantsByIdRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchGetTenantsById(body: CareworkerBatchGetTenantsByIdRequest, options?: any): AxiosPromise<CareworkerBatchGetTenantsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchGetTenantsById(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountDepartments(body: CareworkerBatchUpdateAccountDepartmentsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateAccountDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateAccountDepartments(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountPositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountPositions(body: CareworkerBatchUpdateAccountPositionsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateAccountPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateAccountPositions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountRoles(body: CareworkerBatchUpdateAccountRolesRequest, options?: any): AxiosPromise<CareworkerBatchUpdateAccountRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateAccountRoles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountSessionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccountSessions(body: CareworkerBatchUpdateAccountSessionsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateAccountSessionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateAccountSessions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateAccountsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateAccounts(body: CareworkerBatchUpdateAccountsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateAccountsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateAccounts(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateBedsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateBeds(body: CareworkerBatchUpdateBedsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateBedsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateBeds(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateConfigsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateConfigs(body: CareworkerBatchUpdateConfigsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateConfigsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateConfigs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateCustomersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateCustomers(body: CareworkerBatchUpdateCustomersRequest, options?: any): AxiosPromise<CareworkerBatchUpdateCustomersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateCustomers(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDepartmentsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateDepartments(body: CareworkerBatchUpdateDepartmentsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateDepartments(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDictDataSliceRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateDictDataSlice(body: CareworkerBatchUpdateDictDataSliceRequest, options?: any): AxiosPromise<CareworkerBatchUpdateDictDataSliceResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateDictDataSlice(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateDictTypesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateDictTypes(body: CareworkerBatchUpdateDictTypesRequest, options?: any): AxiosPromise<CareworkerBatchUpdateDictTypesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateDictTypes(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateEmployeesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateEmployees(body: CareworkerBatchUpdateEmployeesRequest, options?: any): AxiosPromise<CareworkerBatchUpdateEmployeesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateEmployees(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateFileCategroysRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateFileCategroys(body: CareworkerBatchUpdateFileCategroysRequest, options?: any): AxiosPromise<CareworkerBatchUpdateFileCategroysResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateFileCategroys(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateFilesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateFiles(body: CareworkerBatchUpdateFilesRequest, options?: any): AxiosPromise<CareworkerBatchUpdateFilesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateFiles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateMenus(body: CareworkerBatchUpdateMenusRequest, options?: any): AxiosPromise<CareworkerBatchUpdateMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateMenus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateNoticeRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateNoticeRecords(body: CareworkerBatchUpdateNoticeRecordsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateNoticeRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateNoticeRecords(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateNoticeSettingsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateNoticeSettings(body: CareworkerBatchUpdateNoticeSettingsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateNoticeSettingsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateNoticeSettings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateOperationLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateOperationLogs(body: CareworkerBatchUpdateOperationLogsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateOperationLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateOperationLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdatePositionsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdatePositions(body: CareworkerBatchUpdatePositionsRequest, options?: any): AxiosPromise<CareworkerBatchUpdatePositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdatePositions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateProjectsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateProjects(body: CareworkerBatchUpdateProjectsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateProjectsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateProjects(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRechargeOrdersRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRechargeOrders(body: CareworkerBatchUpdateRechargeOrdersRequest, options?: any): AxiosPromise<CareworkerBatchUpdateRechargeOrdersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateRechargeOrders(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRefundLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRefundLogs(body: CareworkerBatchUpdateRefundLogsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateRefundLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateRefundLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRefundRecordsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRefundRecords(body: CareworkerBatchUpdateRefundRecordsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateRefundRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateRefundRecords(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRoleMenusRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRoleMenus(body: CareworkerBatchUpdateRoleMenusRequest, options?: any): AxiosPromise<CareworkerBatchUpdateRoleMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateRoleMenus(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateRolesRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateRoles(body: CareworkerBatchUpdateRolesRequest, options?: any): AxiosPromise<CareworkerBatchUpdateRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateRoles(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateSmsLogsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateSmsLogs(body: CareworkerBatchUpdateSmsLogsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateSmsLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateSmsLogs(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBatchUpdateTenantsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceBatchUpdateTenants(body: CareworkerBatchUpdateTenantsRequest, options?: any): AxiosPromise<CareworkerBatchUpdateTenantsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceBatchUpdateTenants(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccount} account The Account resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Account is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccount(account: CareworkerAccount, parent?: string, options?: any): AxiosPromise<CareworkerAccount> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateAccount(account, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountDepartment is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountDepartment(accountDepartment: CareworkerAccountDepartment, parent?: string, options?: any): AxiosPromise<CareworkerAccountDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateAccountDepartment(accountDepartment, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountPosition is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountPosition(accountPosition: CareworkerAccountPosition, parent?: string, options?: any): AxiosPromise<CareworkerAccountPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateAccountPosition(accountPosition, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountRole} accountRole The AccountRole resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountRole is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountRole(accountRole: CareworkerAccountRole, parent?: string, options?: any): AxiosPromise<CareworkerAccountRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateAccountRole(accountRole, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountSession} accountSession The AccountSession resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the AccountSession is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateAccountSession(accountSession: CareworkerAccountSession, parent?: string, options?: any): AxiosPromise<CareworkerAccountSession> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateAccountSession(accountSession, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBed} bed The Bed resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Bed is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateBed(bed: CareworkerBed, parent?: string, options?: any): AxiosPromise<CareworkerBed> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateBed(bed, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerConfig} config The Config resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Config is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateConfig(config: CareworkerConfig, parent?: string, options?: any): AxiosPromise<CareworkerConfig> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateConfig(config, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerCustomer} customer The Customer resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Customer is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateCustomer(customer: CareworkerCustomer, parent?: string, options?: any): AxiosPromise<CareworkerCustomer> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateCustomer(customer, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerDepartment} department The Department resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Department is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateDepartment(department: CareworkerDepartment, parent?: string, options?: any): AxiosPromise<CareworkerDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateDepartment(department, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerDictData} dictData The DictData resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the DictData is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateDictData(dictData: CareworkerDictData, parent?: string, options?: any): AxiosPromise<CareworkerDictData> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateDictData(dictData, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerDictType} dictType The DictType resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the DictType is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateDictType(dictType: CareworkerDictType, parent?: string, options?: any): AxiosPromise<CareworkerDictType> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateDictType(dictType, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerEmployee} employee The Employee resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Employee is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateEmployee(employee: CareworkerEmployee, parent?: string, options?: any): AxiosPromise<CareworkerEmployee> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateEmployee(employee, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerFile} file The File resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the File is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateFile(file: CareworkerFile, parent?: string, options?: any): AxiosPromise<CareworkerFile> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateFile(file, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the FileCategroy is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateFileCategroy(fileCategroy: CareworkerFileCategroy, parent?: string, options?: any): AxiosPromise<CareworkerFileCategroy> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateFileCategroy(fileCategroy, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerMenu} menu The Menu resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Menu is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateMenu(menu: CareworkerMenu, parent?: string, options?: any): AxiosPromise<CareworkerMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateMenu(menu, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the NoticeRecord is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateNoticeRecord(noticeRecord: CareworkerNoticeRecord, parent?: string, options?: any): AxiosPromise<CareworkerNoticeRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateNoticeRecord(noticeRecord, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the NoticeSetting is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateNoticeSetting(noticeSetting: CareworkerNoticeSetting, parent?: string, options?: any): AxiosPromise<CareworkerNoticeSetting> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateNoticeSetting(noticeSetting, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerOperationLog} operationLog The OperationLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the OperationLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateOperationLog(operationLog: CareworkerOperationLog, parent?: string, options?: any): AxiosPromise<CareworkerOperationLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateOperationLog(operationLog, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerPosition} position The Position resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Position is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreatePosition(position: CareworkerPosition, parent?: string, options?: any): AxiosPromise<CareworkerPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreatePosition(position, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerProject} project The Project resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Project is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateProject(project: CareworkerProject, parent?: string, options?: any): AxiosPromise<CareworkerProject> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateProject(project, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RechargeOrder is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRechargeOrder(rechargeOrder: CareworkerRechargeOrder, parent?: string, options?: any): AxiosPromise<CareworkerRechargeOrder> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateRechargeOrder(rechargeOrder, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRefundLog} refundLog The RefundLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RefundLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRefundLog(refundLog: CareworkerRefundLog, parent?: string, options?: any): AxiosPromise<CareworkerRefundLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateRefundLog(refundLog, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RefundRecord is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRefundRecord(refundRecord: CareworkerRefundRecord, parent?: string, options?: any): AxiosPromise<CareworkerRefundRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateRefundRecord(refundRecord, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRole} role The Role resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Role is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRole(role: CareworkerRole, parent?: string, options?: any): AxiosPromise<CareworkerRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateRole(role, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the RoleMenu is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateRoleMenu(roleMenu: CareworkerRoleMenu, parent?: string, options?: any): AxiosPromise<CareworkerRoleMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateRoleMenu(roleMenu, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerSmsLog} smsLog The SmsLog resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the SmsLog is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateSmsLog(smsLog: CareworkerSmsLog, parent?: string, options?: any): AxiosPromise<CareworkerSmsLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateSmsLog(smsLog, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerTenant} tenant The Tenant resource to create. The field name should match the Noun in the method name.
         * @param {string} [parent] The parent resource name where the Tenant is to be created.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceCreateTenant(tenant: CareworkerTenant, parent?: string, options?: any): AxiosPromise<CareworkerTenant> {
            return CareworkerServiceApiFp(configuration).careworkerServiceCreateTenant(tenant, parent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Account to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccount(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteAccount(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the AccountDepartment to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountDepartment(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteAccountDepartment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the AccountPosition to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountPosition(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteAccountPosition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the AccountRole to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountRole(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteAccountRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the AccountSession to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteAccountSession(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteAccountSession(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Bed to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteBed(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteBed(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Config to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteConfig(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Customer to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteCustomer(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteCustomer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Department to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteDepartment(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteDepartment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the DictData to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteDictData(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteDictData(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the DictType to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteDictType(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteDictType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Employee to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteEmployee(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteEmployee(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the File to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteFile(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the FileCategroy to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteFileCategroy(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteFileCategroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Menu to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteMenu(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteMenu(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the NoticeRecord to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteNoticeRecord(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteNoticeRecord(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the NoticeSetting to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteNoticeSetting(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteNoticeSetting(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the OperationLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteOperationLog(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteOperationLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Position to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeletePosition(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeletePosition(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Project to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteProject(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteProject(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the RechargeOrder to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRechargeOrder(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteRechargeOrder(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the RefundLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRefundLog(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteRefundLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the RefundRecord to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRefundRecord(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteRefundRecord(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Role to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRole(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteRole(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the RoleMenu to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteRoleMenu(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteRoleMenu(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the SmsLog to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteSmsLog(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteSmsLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The resource id of the Tenant to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceDeleteTenant(id: string, options?: any): AxiosPromise<object> {
            return CareworkerServiceApiFp(configuration).careworkerServiceDeleteTenant(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccount> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccount> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountByName(name, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccount> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountDepartmentByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountDepartmentByAccountId(accountId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} departmentId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountDepartmentByDepartmentId(departmentId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountDepartmentByDepartmentId(departmentId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountDepartmentById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountDepartmentById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountPositionByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountPositionByAccountId(accountId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountPositionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountPositionById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} positionId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountPositionByPositionId(positionId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountPositionByPositionId(positionId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountRoleByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountRoleByAccountId(accountId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountRoleById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountRoleById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roleId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountRoleByRoleId(roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountRoleByRoleId(roleId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} accountId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionByAccountId(accountId: number, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountSession> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountSessionByAccountId(accountId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountSession> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountSessionById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} terminal The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionByTerminal(terminal: boolean, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountSession> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountSessionByTerminal(terminal, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetAccountSessionByToken(token: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerAccountSession> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetAccountSessionByToken(token, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetBedById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerBed> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetBedById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetBedByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerBed> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetBedByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetConfigById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerConfig> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetConfigById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetConfigByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerConfig> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetConfigByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerCustomer> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetCustomerById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerCustomer> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetCustomerByName(name, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} sn The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerBySn(sn: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerCustomer> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetCustomerBySn(sn, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetCustomerByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerCustomer> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetCustomerByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDepartmentById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetDepartmentById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} projectId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDepartmentByProjectId(projectId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetDepartmentByProjectId(projectId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDepartmentByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetDepartmentByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDictDataById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerDictData> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetDictDataById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetDictTypeById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerDictType> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetDictTypeById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetEmployeeById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerEmployee> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetEmployeeById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetEmployeeByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerEmployee> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetEmployeeByName(name, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetEmployeeByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerEmployee> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetEmployeeByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerFile> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetFileById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerFile> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetFileByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileCategroyById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerFileCategroy> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetFileCategroyById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetFileCategroyByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerFileCategroy> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetFileCategroyByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetMenuById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetMenuById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} employeeId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeRecordByEmployeeId(employeeId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerNoticeRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetNoticeRecordByEmployeeId(employeeId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeRecordById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerNoticeRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetNoticeRecordById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeRecordByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerNoticeRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetNoticeRecordByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeSettingById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerNoticeSetting> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetNoticeSettingById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetNoticeSettingByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerNoticeSetting> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetNoticeSettingByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetOperationLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerOperationLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetOperationLogById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetPositionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetPositionById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetPositionByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetPositionByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetProjectById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerProject> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetProjectById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetProjectByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerProject> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetProjectByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRechargeOrderById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRechargeOrder> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRechargeOrderById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRechargeOrderByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRechargeOrder> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRechargeOrderByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRefundLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRefundLogById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundLogByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRefundLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRefundLogByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundRecordById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRefundRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRefundRecordById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRefundRecordByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRefundRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRefundRecordByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRoleById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleMenuById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRoleMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRoleMenuById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} menuId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleMenuByMenuId(menuId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRoleMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRoleMenuByMenuId(menuId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} roleId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetRoleMenuByRoleId(roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerRoleMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetRoleMenuByRoleId(roleId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetSmsLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerSmsLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetSmsLogById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} tenantId The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetSmsLogByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerSmsLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetSmsLogByTenantId(tenantId, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The field will contain name of the resource requested.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceGetTenantById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerTenant> {
            return CareworkerServiceApiFp(configuration).careworkerServiceGetTenantById(id, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountDepartments(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListAccountDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListAccountDepartments(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountPositions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListAccountPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListAccountPositions(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountRoles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListAccountRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListAccountRoles(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccountSessions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListAccountSessionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListAccountSessions(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListAccounts(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListAccountsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListAccounts(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [parent] The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListBeds(parent?: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListBedsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListBeds(parent, pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} parent The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListBedsWithDepartment(parent: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListBedsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListBedsWithDepartment(parent, pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListConfigs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListConfigsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListConfigs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListCustomers(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListCustomersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListCustomers(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListDepartments(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListDepartmentsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListDepartments(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListDictDataSlice(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListDictDataSliceResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListDictDataSlice(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListDictTypes(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListDictTypesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListDictTypes(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListEmployees(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListEmployeesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListEmployees(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListFileCategroys(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListFileCategroysResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListFileCategroys(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListFiles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListFilesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListFiles(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListMenus(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListMenus(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListNoticeRecords(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListNoticeRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListNoticeRecords(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListNoticeSettings(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListNoticeSettingsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListNoticeSettings(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListOperationLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListOperationLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListOperationLogs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListPositions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListPositionsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListPositions(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListProjects(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListProjectsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListProjects(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRechargeOrders(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListRechargeOrdersResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListRechargeOrders(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRefundLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListRefundLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListRefundLogs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRefundRecords(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListRefundRecordsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListRefundRecords(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRoleMenus(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListRoleMenusResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListRoleMenus(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListRoles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListRolesResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListRoles(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListSmsLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListSmsLogsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListSmsLogs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [pageSize] The maximum number of items to return.
         * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
         * @param {string} [filter] 
         * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
         * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceListTenants(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any): AxiosPromise<CareworkerListTenantsResponse> {
            return CareworkerServiceApiFp(configuration).careworkerServiceListTenants(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccount} account The Account resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccount(account: CareworkerAccount, options?: any): AxiosPromise<CareworkerAccount> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateAccount(account, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountDepartment(accountDepartment: CareworkerAccountDepartment, options?: any): AxiosPromise<CareworkerAccountDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateAccountDepartment(accountDepartment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountPosition(accountPosition: CareworkerAccountPosition, options?: any): AxiosPromise<CareworkerAccountPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateAccountPosition(accountPosition, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountRole} accountRole The AccountRole resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountRole(accountRole: CareworkerAccountRole, options?: any): AxiosPromise<CareworkerAccountRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateAccountRole(accountRole, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerAccountSession} accountSession The AccountSession resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateAccountSession(accountSession: CareworkerAccountSession, options?: any): AxiosPromise<CareworkerAccountSession> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateAccountSession(accountSession, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerBed} bed The Bed resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateBed(bed: CareworkerBed, options?: any): AxiosPromise<CareworkerBed> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateBed(bed, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerConfig} config The Config resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateConfig(config: CareworkerConfig, options?: any): AxiosPromise<CareworkerConfig> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateConfig(config, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerCustomer} customer The Customer resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateCustomer(customer: CareworkerCustomer, options?: any): AxiosPromise<CareworkerCustomer> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateCustomer(customer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerDepartment} department The Department resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateDepartment(department: CareworkerDepartment, options?: any): AxiosPromise<CareworkerDepartment> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateDepartment(department, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerDictData} dictData The DictData resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateDictData(dictData: CareworkerDictData, options?: any): AxiosPromise<CareworkerDictData> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateDictData(dictData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerDictType} dictType The DictType resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateDictType(dictType: CareworkerDictType, options?: any): AxiosPromise<CareworkerDictType> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateDictType(dictType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerEmployee} employee The Employee resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateEmployee(employee: CareworkerEmployee, options?: any): AxiosPromise<CareworkerEmployee> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateEmployee(employee, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerFile} file The File resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateFile(file: CareworkerFile, options?: any): AxiosPromise<CareworkerFile> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateFileCategroy(fileCategroy: CareworkerFileCategroy, options?: any): AxiosPromise<CareworkerFileCategroy> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateFileCategroy(fileCategroy, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerMenu} menu The Menu resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateMenu(menu: CareworkerMenu, options?: any): AxiosPromise<CareworkerMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateMenu(menu, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateNoticeRecord(noticeRecord: CareworkerNoticeRecord, options?: any): AxiosPromise<CareworkerNoticeRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateNoticeRecord(noticeRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateNoticeSetting(noticeSetting: CareworkerNoticeSetting, options?: any): AxiosPromise<CareworkerNoticeSetting> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateNoticeSetting(noticeSetting, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerOperationLog} operationLog The OperationLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateOperationLog(operationLog: CareworkerOperationLog, options?: any): AxiosPromise<CareworkerOperationLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateOperationLog(operationLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerPosition} position The Position resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdatePosition(position: CareworkerPosition, options?: any): AxiosPromise<CareworkerPosition> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdatePosition(position, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerProject} project The Project resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateProject(project: CareworkerProject, options?: any): AxiosPromise<CareworkerProject> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateProject(project, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRechargeOrder(rechargeOrder: CareworkerRechargeOrder, options?: any): AxiosPromise<CareworkerRechargeOrder> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateRechargeOrder(rechargeOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRefundLog} refundLog The RefundLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRefundLog(refundLog: CareworkerRefundLog, options?: any): AxiosPromise<CareworkerRefundLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateRefundLog(refundLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRefundRecord(refundRecord: CareworkerRefundRecord, options?: any): AxiosPromise<CareworkerRefundRecord> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateRefundRecord(refundRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRole} role The Role resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRole(role: CareworkerRole, options?: any): AxiosPromise<CareworkerRole> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateRole(role, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateRoleMenu(roleMenu: CareworkerRoleMenu, options?: any): AxiosPromise<CareworkerRoleMenu> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateRoleMenu(roleMenu, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerSmsLog} smsLog The SmsLog resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateSmsLog(smsLog: CareworkerSmsLog, options?: any): AxiosPromise<CareworkerSmsLog> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateSmsLog(smsLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CareworkerTenant} tenant The Tenant resource which replaces the resource on the server.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        careworkerServiceUpdateTenant(tenant: CareworkerTenant, options?: any): AxiosPromise<CareworkerTenant> {
            return CareworkerServiceApiFp(configuration).careworkerServiceUpdateTenant(tenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CareworkerServiceApi - object-oriented interface
 * @export
 * @class CareworkerServiceApi
 * @extends {BaseAPI}
 */
export class CareworkerServiceApi extends BaseAPI {
    /**
     * 
     * @param {CareworkerBatchCreateAccountDepartmentsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateAccountDepartments(body: CareworkerBatchCreateAccountDepartmentsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateAccountDepartments(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateAccountPositionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateAccountPositions(body: CareworkerBatchCreateAccountPositionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateAccountPositions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateAccountRolesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateAccountRoles(body: CareworkerBatchCreateAccountRolesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateAccountRoles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateAccountSessionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateAccountSessions(body: CareworkerBatchCreateAccountSessionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateAccountSessions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateAccountsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateAccounts(body: CareworkerBatchCreateAccountsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateAccounts(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateBedsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateBeds(body: CareworkerBatchCreateBedsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateBeds(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateConfigsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateConfigs(body: CareworkerBatchCreateConfigsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateConfigs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateCustomersRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateCustomers(body: CareworkerBatchCreateCustomersRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateCustomers(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateDepartmentsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateDepartments(body: CareworkerBatchCreateDepartmentsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateDepartments(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateDictDataSliceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateDictDataSlice(body: CareworkerBatchCreateDictDataSliceRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateDictDataSlice(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateDictTypesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateDictTypes(body: CareworkerBatchCreateDictTypesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateDictTypes(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateEmployeesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateEmployees(body: CareworkerBatchCreateEmployeesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateEmployees(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateFileCategroysRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateFileCategroys(body: CareworkerBatchCreateFileCategroysRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateFileCategroys(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateFilesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateFiles(body: CareworkerBatchCreateFilesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateFiles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateMenusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateMenus(body: CareworkerBatchCreateMenusRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateMenus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateNoticeRecordsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateNoticeRecords(body: CareworkerBatchCreateNoticeRecordsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateNoticeRecords(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateNoticeSettingsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateNoticeSettings(body: CareworkerBatchCreateNoticeSettingsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateNoticeSettings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateOperationLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateOperationLogs(body: CareworkerBatchCreateOperationLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateOperationLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreatePositionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreatePositions(body: CareworkerBatchCreatePositionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreatePositions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateProjectsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateProjects(body: CareworkerBatchCreateProjectsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateProjects(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateRechargeOrdersRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateRechargeOrders(body: CareworkerBatchCreateRechargeOrdersRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateRechargeOrders(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateRefundLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateRefundLogs(body: CareworkerBatchCreateRefundLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateRefundLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateRefundRecordsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateRefundRecords(body: CareworkerBatchCreateRefundRecordsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateRefundRecords(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateRoleMenusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateRoleMenus(body: CareworkerBatchCreateRoleMenusRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateRoleMenus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateRolesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateRoles(body: CareworkerBatchCreateRolesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateRoles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateSmsLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateSmsLogs(body: CareworkerBatchCreateSmsLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateSmsLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchCreateTenantsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchCreateTenants(body: CareworkerBatchCreateTenantsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchCreateTenants(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteAccountDepartmentsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteAccountDepartments(body: CareworkerBatchDeleteAccountDepartmentsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteAccountDepartments(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteAccountPositionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteAccountPositions(body: CareworkerBatchDeleteAccountPositionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteAccountPositions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteAccountRolesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteAccountRoles(body: CareworkerBatchDeleteAccountRolesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteAccountRoles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteAccountSessionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteAccountSessions(body: CareworkerBatchDeleteAccountSessionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteAccountSessions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteAccountsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteAccounts(body: CareworkerBatchDeleteAccountsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteAccounts(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteBedsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteBeds(body: CareworkerBatchDeleteBedsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteBeds(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteConfigsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteConfigs(body: CareworkerBatchDeleteConfigsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteConfigs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteCustomersRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteCustomers(body: CareworkerBatchDeleteCustomersRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteCustomers(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteDepartmentsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteDepartments(body: CareworkerBatchDeleteDepartmentsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteDepartments(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteDictDataSliceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteDictDataSlice(body: CareworkerBatchDeleteDictDataSliceRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteDictDataSlice(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteDictTypesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteDictTypes(body: CareworkerBatchDeleteDictTypesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteDictTypes(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteEmployeesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteEmployees(body: CareworkerBatchDeleteEmployeesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteEmployees(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteFileCategroysRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteFileCategroys(body: CareworkerBatchDeleteFileCategroysRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteFileCategroys(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteFilesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteFiles(body: CareworkerBatchDeleteFilesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteFiles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteMenusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteMenus(body: CareworkerBatchDeleteMenusRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteMenus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteNoticeRecordsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteNoticeRecords(body: CareworkerBatchDeleteNoticeRecordsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteNoticeRecords(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteNoticeSettingsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteNoticeSettings(body: CareworkerBatchDeleteNoticeSettingsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteNoticeSettings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteOperationLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteOperationLogs(body: CareworkerBatchDeleteOperationLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteOperationLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeletePositionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeletePositions(body: CareworkerBatchDeletePositionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeletePositions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteProjectsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteProjects(body: CareworkerBatchDeleteProjectsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteProjects(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteRechargeOrdersRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteRechargeOrders(body: CareworkerBatchDeleteRechargeOrdersRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteRechargeOrders(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteRefundLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteRefundLogs(body: CareworkerBatchDeleteRefundLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteRefundLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteRefundRecordsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteRefundRecords(body: CareworkerBatchDeleteRefundRecordsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteRefundRecords(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteRoleMenusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteRoleMenus(body: CareworkerBatchDeleteRoleMenusRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteRoleMenus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteRolesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteRoles(body: CareworkerBatchDeleteRolesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteRoles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteSmsLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteSmsLogs(body: CareworkerBatchDeleteSmsLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteSmsLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchDeleteTenantsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchDeleteTenants(body: CareworkerBatchDeleteTenantsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchDeleteTenants(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountDepartmentsByAccountIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountDepartmentsByAccountId(body: CareworkerBatchGetAccountDepartmentsByAccountIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountDepartmentsByAccountId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountDepartmentsByDepartmentId(body: CareworkerBatchGetAccountDepartmentsByDepartmentIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountDepartmentsByDepartmentId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountDepartmentsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountDepartmentsById(body: CareworkerBatchGetAccountDepartmentsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountDepartmentsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountPositionsByAccountIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountPositionsByAccountId(body: CareworkerBatchGetAccountPositionsByAccountIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountPositionsByAccountId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountPositionsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountPositionsById(body: CareworkerBatchGetAccountPositionsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountPositionsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountPositionsByPositionIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountPositionsByPositionId(body: CareworkerBatchGetAccountPositionsByPositionIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountPositionsByPositionId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountRolesByAccountIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountRolesByAccountId(body: CareworkerBatchGetAccountRolesByAccountIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountRolesByAccountId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountRolesByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountRolesById(body: CareworkerBatchGetAccountRolesByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountRolesById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountRolesByRoleIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountRolesByRoleId(body: CareworkerBatchGetAccountRolesByRoleIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountRolesByRoleId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountSessionsByAccountIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountSessionsByAccountId(body: CareworkerBatchGetAccountSessionsByAccountIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountSessionsByAccountId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountSessionsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountSessionsById(body: CareworkerBatchGetAccountSessionsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountSessionsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountSessionsByTerminalRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountSessionsByTerminal(body: CareworkerBatchGetAccountSessionsByTerminalRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountSessionsByTerminal(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountSessionsByTokenRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountSessionsByToken(body: CareworkerBatchGetAccountSessionsByTokenRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountSessionsByToken(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountsById(body: CareworkerBatchGetAccountsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountsByNameRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountsByName(body: CareworkerBatchGetAccountsByNameRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountsByName(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetAccountsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetAccountsByTenantId(body: CareworkerBatchGetAccountsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetAccountsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetBedsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetBedsById(body: CareworkerBatchGetBedsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetBedsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetBedsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetBedsByTenantId(body: CareworkerBatchGetBedsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetBedsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetConfigsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetConfigsById(body: CareworkerBatchGetConfigsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetConfigsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetConfigsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetConfigsByTenantId(body: CareworkerBatchGetConfigsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetConfigsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetCustomersByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetCustomersById(body: CareworkerBatchGetCustomersByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetCustomersById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetCustomersByNameRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetCustomersByName(body: CareworkerBatchGetCustomersByNameRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetCustomersByName(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetCustomersBySnRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetCustomersBySn(body: CareworkerBatchGetCustomersBySnRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetCustomersBySn(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetCustomersByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetCustomersByTenantId(body: CareworkerBatchGetCustomersByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetCustomersByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetDepartmentsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetDepartmentsById(body: CareworkerBatchGetDepartmentsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetDepartmentsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetDepartmentsByProjectIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetDepartmentsByProjectId(body: CareworkerBatchGetDepartmentsByProjectIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetDepartmentsByProjectId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetDepartmentsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetDepartmentsByTenantId(body: CareworkerBatchGetDepartmentsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetDepartmentsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetDictDataSliceByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetDictDataSliceById(body: CareworkerBatchGetDictDataSliceByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetDictDataSliceById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetDictTypesByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetDictTypesById(body: CareworkerBatchGetDictTypesByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetDictTypesById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetEmployeesByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetEmployeesById(body: CareworkerBatchGetEmployeesByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetEmployeesById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetEmployeesByNameRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetEmployeesByName(body: CareworkerBatchGetEmployeesByNameRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetEmployeesByName(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetEmployeesByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetEmployeesByTenantId(body: CareworkerBatchGetEmployeesByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetEmployeesByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetFileCategroysByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetFileCategroysById(body: CareworkerBatchGetFileCategroysByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetFileCategroysById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetFileCategroysByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetFileCategroysByTenantId(body: CareworkerBatchGetFileCategroysByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetFileCategroysByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetFilesByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetFilesById(body: CareworkerBatchGetFilesByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetFilesById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetFilesByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetFilesByTenantId(body: CareworkerBatchGetFilesByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetFilesByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetMenusByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetMenusById(body: CareworkerBatchGetMenusByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetMenusById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetNoticeRecordsByEmployeeIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetNoticeRecordsByEmployeeId(body: CareworkerBatchGetNoticeRecordsByEmployeeIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetNoticeRecordsByEmployeeId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetNoticeRecordsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetNoticeRecordsById(body: CareworkerBatchGetNoticeRecordsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetNoticeRecordsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetNoticeRecordsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetNoticeRecordsByTenantId(body: CareworkerBatchGetNoticeRecordsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetNoticeRecordsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetNoticeSettingsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetNoticeSettingsById(body: CareworkerBatchGetNoticeSettingsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetNoticeSettingsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetNoticeSettingsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetNoticeSettingsByTenantId(body: CareworkerBatchGetNoticeSettingsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetNoticeSettingsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetOperationLogsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetOperationLogsById(body: CareworkerBatchGetOperationLogsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetOperationLogsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetPositionsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetPositionsById(body: CareworkerBatchGetPositionsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetPositionsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetPositionsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetPositionsByTenantId(body: CareworkerBatchGetPositionsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetPositionsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetProjectsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetProjectsById(body: CareworkerBatchGetProjectsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetProjectsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetProjectsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetProjectsByTenantId(body: CareworkerBatchGetProjectsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetProjectsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRechargeOrdersByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRechargeOrdersById(body: CareworkerBatchGetRechargeOrdersByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRechargeOrdersById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRechargeOrdersByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRechargeOrdersByTenantId(body: CareworkerBatchGetRechargeOrdersByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRechargeOrdersByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRefundLogsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRefundLogsById(body: CareworkerBatchGetRefundLogsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRefundLogsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRefundLogsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRefundLogsByTenantId(body: CareworkerBatchGetRefundLogsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRefundLogsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRefundRecordsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRefundRecordsById(body: CareworkerBatchGetRefundRecordsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRefundRecordsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRefundRecordsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRefundRecordsByTenantId(body: CareworkerBatchGetRefundRecordsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRefundRecordsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRoleMenusByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRoleMenusById(body: CareworkerBatchGetRoleMenusByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRoleMenusById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRoleMenusByMenuIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRoleMenusByMenuId(body: CareworkerBatchGetRoleMenusByMenuIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRoleMenusByMenuId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRoleMenusByRoleIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRoleMenusByRoleId(body: CareworkerBatchGetRoleMenusByRoleIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRoleMenusByRoleId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetRolesByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetRolesById(body: CareworkerBatchGetRolesByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetRolesById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetSmsLogsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetSmsLogsById(body: CareworkerBatchGetSmsLogsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetSmsLogsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetSmsLogsByTenantIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetSmsLogsByTenantId(body: CareworkerBatchGetSmsLogsByTenantIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetSmsLogsByTenantId(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchGetTenantsByIdRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchGetTenantsById(body: CareworkerBatchGetTenantsByIdRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchGetTenantsById(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateAccountDepartmentsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateAccountDepartments(body: CareworkerBatchUpdateAccountDepartmentsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateAccountDepartments(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateAccountPositionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateAccountPositions(body: CareworkerBatchUpdateAccountPositionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateAccountPositions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateAccountRolesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateAccountRoles(body: CareworkerBatchUpdateAccountRolesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateAccountRoles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateAccountSessionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateAccountSessions(body: CareworkerBatchUpdateAccountSessionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateAccountSessions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateAccountsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateAccounts(body: CareworkerBatchUpdateAccountsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateAccounts(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateBedsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateBeds(body: CareworkerBatchUpdateBedsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateBeds(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateConfigsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateConfigs(body: CareworkerBatchUpdateConfigsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateConfigs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateCustomersRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateCustomers(body: CareworkerBatchUpdateCustomersRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateCustomers(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateDepartmentsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateDepartments(body: CareworkerBatchUpdateDepartmentsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateDepartments(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateDictDataSliceRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateDictDataSlice(body: CareworkerBatchUpdateDictDataSliceRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateDictDataSlice(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateDictTypesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateDictTypes(body: CareworkerBatchUpdateDictTypesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateDictTypes(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateEmployeesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateEmployees(body: CareworkerBatchUpdateEmployeesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateEmployees(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateFileCategroysRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateFileCategroys(body: CareworkerBatchUpdateFileCategroysRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateFileCategroys(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateFilesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateFiles(body: CareworkerBatchUpdateFilesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateFiles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateMenusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateMenus(body: CareworkerBatchUpdateMenusRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateMenus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateNoticeRecordsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateNoticeRecords(body: CareworkerBatchUpdateNoticeRecordsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateNoticeRecords(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateNoticeSettingsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateNoticeSettings(body: CareworkerBatchUpdateNoticeSettingsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateNoticeSettings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateOperationLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateOperationLogs(body: CareworkerBatchUpdateOperationLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateOperationLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdatePositionsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdatePositions(body: CareworkerBatchUpdatePositionsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdatePositions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateProjectsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateProjects(body: CareworkerBatchUpdateProjectsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateProjects(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateRechargeOrdersRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateRechargeOrders(body: CareworkerBatchUpdateRechargeOrdersRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateRechargeOrders(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateRefundLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateRefundLogs(body: CareworkerBatchUpdateRefundLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateRefundLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateRefundRecordsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateRefundRecords(body: CareworkerBatchUpdateRefundRecordsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateRefundRecords(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateRoleMenusRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateRoleMenus(body: CareworkerBatchUpdateRoleMenusRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateRoleMenus(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateRolesRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateRoles(body: CareworkerBatchUpdateRolesRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateRoles(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateSmsLogsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateSmsLogs(body: CareworkerBatchUpdateSmsLogsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateSmsLogs(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBatchUpdateTenantsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceBatchUpdateTenants(body: CareworkerBatchUpdateTenantsRequest, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceBatchUpdateTenants(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccount} account The Account resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Account is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateAccount(account: CareworkerAccount, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateAccount(account, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the AccountDepartment is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateAccountDepartment(accountDepartment: CareworkerAccountDepartment, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateAccountDepartment(accountDepartment, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the AccountPosition is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateAccountPosition(accountPosition: CareworkerAccountPosition, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateAccountPosition(accountPosition, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountRole} accountRole The AccountRole resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the AccountRole is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateAccountRole(accountRole: CareworkerAccountRole, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateAccountRole(accountRole, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountSession} accountSession The AccountSession resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the AccountSession is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateAccountSession(accountSession: CareworkerAccountSession, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateAccountSession(accountSession, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBed} bed The Bed resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Bed is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateBed(bed: CareworkerBed, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateBed(bed, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerConfig} config The Config resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Config is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateConfig(config: CareworkerConfig, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateConfig(config, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerCustomer} customer The Customer resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Customer is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateCustomer(customer: CareworkerCustomer, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateCustomer(customer, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerDepartment} department The Department resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Department is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateDepartment(department: CareworkerDepartment, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateDepartment(department, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerDictData} dictData The DictData resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the DictData is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateDictData(dictData: CareworkerDictData, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateDictData(dictData, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerDictType} dictType The DictType resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the DictType is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateDictType(dictType: CareworkerDictType, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateDictType(dictType, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerEmployee} employee The Employee resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Employee is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateEmployee(employee: CareworkerEmployee, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateEmployee(employee, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerFile} file The File resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the File is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateFile(file: CareworkerFile, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateFile(file, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the FileCategroy is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateFileCategroy(fileCategroy: CareworkerFileCategroy, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateFileCategroy(fileCategroy, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerMenu} menu The Menu resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Menu is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateMenu(menu: CareworkerMenu, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateMenu(menu, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the NoticeRecord is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateNoticeRecord(noticeRecord: CareworkerNoticeRecord, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateNoticeRecord(noticeRecord, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the NoticeSetting is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateNoticeSetting(noticeSetting: CareworkerNoticeSetting, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateNoticeSetting(noticeSetting, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerOperationLog} operationLog The OperationLog resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the OperationLog is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateOperationLog(operationLog: CareworkerOperationLog, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateOperationLog(operationLog, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerPosition} position The Position resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Position is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreatePosition(position: CareworkerPosition, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreatePosition(position, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerProject} project The Project resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Project is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateProject(project: CareworkerProject, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateProject(project, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the RechargeOrder is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateRechargeOrder(rechargeOrder: CareworkerRechargeOrder, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateRechargeOrder(rechargeOrder, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRefundLog} refundLog The RefundLog resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the RefundLog is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateRefundLog(refundLog: CareworkerRefundLog, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateRefundLog(refundLog, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the RefundRecord is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateRefundRecord(refundRecord: CareworkerRefundRecord, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateRefundRecord(refundRecord, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRole} role The Role resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Role is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateRole(role: CareworkerRole, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateRole(role, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the RoleMenu is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateRoleMenu(roleMenu: CareworkerRoleMenu, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateRoleMenu(roleMenu, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerSmsLog} smsLog The SmsLog resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the SmsLog is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateSmsLog(smsLog: CareworkerSmsLog, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateSmsLog(smsLog, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerTenant} tenant The Tenant resource to create. The field name should match the Noun in the method name.
     * @param {string} [parent] The parent resource name where the Tenant is to be created.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceCreateTenant(tenant: CareworkerTenant, parent?: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceCreateTenant(tenant, parent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Account to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteAccount(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteAccount(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the AccountDepartment to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteAccountDepartment(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteAccountDepartment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the AccountPosition to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteAccountPosition(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteAccountPosition(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the AccountRole to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteAccountRole(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteAccountRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the AccountSession to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteAccountSession(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteAccountSession(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Bed to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteBed(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteBed(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Config to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteConfig(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Customer to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteCustomer(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteCustomer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Department to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteDepartment(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteDepartment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the DictData to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteDictData(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteDictData(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the DictType to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteDictType(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteDictType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Employee to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteEmployee(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteEmployee(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the File to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteFile(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the FileCategroy to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteFileCategroy(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteFileCategroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Menu to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteMenu(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteMenu(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the NoticeRecord to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteNoticeRecord(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteNoticeRecord(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the NoticeSetting to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteNoticeSetting(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteNoticeSetting(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the OperationLog to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteOperationLog(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteOperationLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Position to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeletePosition(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeletePosition(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Project to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteProject(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteProject(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the RechargeOrder to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteRechargeOrder(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteRechargeOrder(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the RefundLog to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteRefundLog(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteRefundLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the RefundRecord to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteRefundRecord(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteRefundRecord(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Role to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteRole(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteRole(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the RoleMenu to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteRoleMenu(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteRoleMenu(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the SmsLog to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteSmsLog(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteSmsLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The resource id of the Tenant to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceDeleteTenant(id: string, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceDeleteTenant(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountByName(name, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountDepartmentByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountDepartmentByAccountId(accountId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} departmentId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountDepartmentByDepartmentId(departmentId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountDepartmentByDepartmentId(departmentId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountDepartmentById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountDepartmentById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountPositionByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountPositionByAccountId(accountId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountPositionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountPositionById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} positionId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountPositionByPositionId(positionId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountPositionByPositionId(positionId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountRoleByAccountId(accountId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountRoleByAccountId(accountId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountRoleById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountRoleById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roleId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountRoleByRoleId(roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountRoleByRoleId(roleId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} accountId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountSessionByAccountId(accountId: number, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountSessionByAccountId(accountId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountSessionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountSessionById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} terminal The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountSessionByTerminal(terminal: boolean, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountSessionByTerminal(terminal, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetAccountSessionByToken(token: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetAccountSessionByToken(token, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetBedById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetBedById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetBedByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetBedByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetConfigById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetConfigById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetConfigByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetConfigByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetCustomerById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetCustomerById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetCustomerByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetCustomerByName(name, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} sn The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetCustomerBySn(sn: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetCustomerBySn(sn, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetCustomerByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetCustomerByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetDepartmentById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetDepartmentById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} projectId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetDepartmentByProjectId(projectId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetDepartmentByProjectId(projectId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetDepartmentByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetDepartmentByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetDictDataById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetDictDataById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetDictTypeById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetDictTypeById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetEmployeeById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetEmployeeById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetEmployeeByName(name: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetEmployeeByName(name, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetEmployeeByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetEmployeeByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetFileById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetFileById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetFileByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetFileByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetFileCategroyById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetFileCategroyById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetFileCategroyByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetFileCategroyByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetMenuById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetMenuById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} employeeId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetNoticeRecordByEmployeeId(employeeId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetNoticeRecordByEmployeeId(employeeId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetNoticeRecordById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetNoticeRecordById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetNoticeRecordByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetNoticeRecordByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetNoticeSettingById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetNoticeSettingById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetNoticeSettingByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetNoticeSettingByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetOperationLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetOperationLogById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetPositionById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetPositionById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetPositionByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetPositionByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetProjectById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetProjectById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetProjectByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetProjectByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRechargeOrderById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRechargeOrderById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRechargeOrderByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRechargeOrderByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRefundLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRefundLogById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRefundLogByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRefundLogByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRefundRecordById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRefundRecordById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRefundRecordByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRefundRecordByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRoleById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRoleById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRoleMenuById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRoleMenuById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} menuId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRoleMenuByMenuId(menuId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRoleMenuByMenuId(menuId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} roleId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetRoleMenuByRoleId(roleId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetRoleMenuByRoleId(roleId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetSmsLogById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetSmsLogById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} tenantId The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetSmsLogByTenantId(tenantId: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetSmsLogByTenantId(tenantId, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The field will contain name of the resource requested.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceGetTenantById(id: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceGetTenantById(id, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListAccountDepartments(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListAccountDepartments(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListAccountPositions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListAccountPositions(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListAccountRoles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListAccountRoles(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListAccountSessions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListAccountSessions(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListAccounts(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListAccounts(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [parent] The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListBeds(parent?: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListBeds(parent, pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} parent The parent resource name, for example, \&quot;shelves/shelf1\&quot;.
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListBedsWithDepartment(parent: string, pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListBedsWithDepartment(parent, pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListConfigs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListConfigs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListCustomers(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListCustomers(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListDepartments(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListDepartments(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListDictDataSlice(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListDictDataSlice(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListDictTypes(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListDictTypes(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListEmployees(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListEmployees(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListFileCategroys(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListFileCategroys(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListFiles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListFiles(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListMenus(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListMenus(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListNoticeRecords(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListNoticeRecords(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListNoticeSettings(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListNoticeSettings(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListOperationLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListOperationLogs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListPositions(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListPositions(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListProjects(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListProjects(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListRechargeOrders(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListRechargeOrders(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListRefundLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListRefundLogs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListRefundRecords(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListRefundRecords(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListRoleMenus(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListRoleMenus(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListRoles(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListRoles(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListSmsLogs(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListSmsLogs(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [pageSize] The maximum number of items to return.
     * @param {string} [pageToken] The next_page_token value returned from a previous List request, if any.
     * @param {string} [filter] 
     * @param {string} [orderBy] The string value should follow SQL syntax: comma separated list of fields. For example: \&quot;foo,bar\&quot;. The default sorting order is ascending. To specify descending order for a field, a suffix \&quot; desc\&quot; should be appended to the field name. For example: \&quot;foo desc,bar\&quot;. Redundant space characters in the syntax are insignificant. \&quot;foo,bar desc\&quot; and \&quot;  foo ,  bar  desc  \&quot; are equivalent.
     * @param {'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES'} [view] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceListTenants(pageSize?: number, pageToken?: string, filter?: string, orderBy?: string, view?: 'VIEW_UNSPECIFIED' | 'BASIC' | 'WITH_EDGES', options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceListTenants(pageSize, pageToken, filter, orderBy, view, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccount} account The Account resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateAccount(account: CareworkerAccount, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateAccount(account, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountDepartment} accountDepartment The AccountDepartment resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateAccountDepartment(accountDepartment: CareworkerAccountDepartment, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateAccountDepartment(accountDepartment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountPosition} accountPosition The AccountPosition resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateAccountPosition(accountPosition: CareworkerAccountPosition, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateAccountPosition(accountPosition, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountRole} accountRole The AccountRole resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateAccountRole(accountRole: CareworkerAccountRole, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateAccountRole(accountRole, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerAccountSession} accountSession The AccountSession resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateAccountSession(accountSession: CareworkerAccountSession, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateAccountSession(accountSession, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerBed} bed The Bed resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateBed(bed: CareworkerBed, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateBed(bed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerConfig} config The Config resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateConfig(config: CareworkerConfig, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateConfig(config, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerCustomer} customer The Customer resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateCustomer(customer: CareworkerCustomer, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateCustomer(customer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerDepartment} department The Department resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateDepartment(department: CareworkerDepartment, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateDepartment(department, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerDictData} dictData The DictData resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateDictData(dictData: CareworkerDictData, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateDictData(dictData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerDictType} dictType The DictType resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateDictType(dictType: CareworkerDictType, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateDictType(dictType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerEmployee} employee The Employee resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateEmployee(employee: CareworkerEmployee, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateEmployee(employee, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerFile} file The File resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateFile(file: CareworkerFile, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateFile(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerFileCategroy} fileCategroy The FileCategroy resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateFileCategroy(fileCategroy: CareworkerFileCategroy, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateFileCategroy(fileCategroy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerMenu} menu The Menu resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateMenu(menu: CareworkerMenu, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateMenu(menu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerNoticeRecord} noticeRecord The NoticeRecord resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateNoticeRecord(noticeRecord: CareworkerNoticeRecord, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateNoticeRecord(noticeRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerNoticeSetting} noticeSetting The NoticeSetting resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateNoticeSetting(noticeSetting: CareworkerNoticeSetting, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateNoticeSetting(noticeSetting, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerOperationLog} operationLog The OperationLog resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateOperationLog(operationLog: CareworkerOperationLog, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateOperationLog(operationLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerPosition} position The Position resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdatePosition(position: CareworkerPosition, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdatePosition(position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerProject} project The Project resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateProject(project: CareworkerProject, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateProject(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRechargeOrder} rechargeOrder The RechargeOrder resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateRechargeOrder(rechargeOrder: CareworkerRechargeOrder, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateRechargeOrder(rechargeOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRefundLog} refundLog The RefundLog resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateRefundLog(refundLog: CareworkerRefundLog, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateRefundLog(refundLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRefundRecord} refundRecord The RefundRecord resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateRefundRecord(refundRecord: CareworkerRefundRecord, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateRefundRecord(refundRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRole} role The Role resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateRole(role: CareworkerRole, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateRole(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerRoleMenu} roleMenu The RoleMenu resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateRoleMenu(roleMenu: CareworkerRoleMenu, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateRoleMenu(roleMenu, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerSmsLog} smsLog The SmsLog resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateSmsLog(smsLog: CareworkerSmsLog, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateSmsLog(smsLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CareworkerTenant} tenant The Tenant resource which replaces the resource on the server.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CareworkerServiceApi
     */
    public careworkerServiceUpdateTenant(tenant: CareworkerTenant, options?: any) {
        return CareworkerServiceApiFp(this.configuration).careworkerServiceUpdateTenant(tenant, options).then((request) => request(this.axios, this.basePath));
    }
}
