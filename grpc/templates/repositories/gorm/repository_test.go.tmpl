{{ $table := . }}

// Code generated by hedone, DO NOT EDIT.
package repogorm

import (
	"context"
	"fmt"
	"testing"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/bxcodec/faker/v3"
	"github.com/google/uuid"
	"gorm.io/driver/mysql"
	"gorm.io/gorm"

	"{{ .Package }}/models"
)

//TODO: Add more test case
func TestList{{ $table.Name | pascal | plural }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	{{/*TODO: op test */}}
	{{- if and $table.HasFilterField false}}
		{{- $f := index $table.FilterFields 0 }}
		{{- $op := index $f.Ops 0 }}

		var filterValue1, filterValue2 {{ $f.Type.Kind }}
		faker.FakeData(&filterValue1)
		faker.FakeData(&filterValue2)

		filter := &models.{{ $table.Name | pascal }}FilterInput{
			{{ $f.Name | pascal }}: &models.{{ $table.Name | pascal }}Op{{ $f.Name | pascal }}Input{
				{{ $op.Name }}: &filterValue1,
			},
			NOT: &models.{{ $table.Name | pascal }}FilterInput{
				{{ $f.Name | pascal }}: &models.{{ $table.Name | pascal }}Op{{ $f.Name | pascal }}Input{
					{{ $op.Name }}: &filterValue1,
				},
			},
			AND: []*models.{{ $table.Name | pascal }}FilterInput{
				{
					{{ $f.Name | pascal }}: &models.{{ $table.Name | pascal }}Op{{ $f.Name | pascal }}Input{
						{{ $op.Name }}: &filterValue1,
					},
				},
				{
					{{ $f.Name | pascal }}: &models.{{ $table.Name | pascal }}Op{{ $f.Name | pascal }}Input{
						{{ $op.Name }}: &filterValue2,
					},
				},
			},
			OR: []*models.{{ $table.Name | pascal }}FilterInput{
				{
					{{ $f.Name | pascal }}: &models.{{ $table.Name | pascal }}Op{{ $f.Name | pascal }}Input{
						{{ $op.Name }}: &filterValue1,
					},
				},
				{
					{{ $f.Name | pascal }}: &models.{{ $table.Name | pascal }}Op{{ $f.Name | pascal }}Input{
						{{ $op.Name }}: &filterValue2,
					},
				},
			},
		}
	{{- end}}

	results := []struct {
		parent  string
		parentName  string
		filter  *models.{{ $table.Name | pascal }}FilterInput
		orderBy string
		count   int32
		token   string
		before  func(sqlmock.Sqlmock)
		wantErr bool
	}{
		{
			parent: "",
			parentName: "",
			filter: nil,
			before: func(mock sqlmock.Sqlmock) {
				query := fmt.Sprintf("SELECT count(*) FROM `{{ $table.Name }}` LIMIT %d", MaxLimit+1)
				mock.ExpectQuery(escape(query)).WillReturnRows(sqlmock.NewRows([]string{"10"}))
				query = fmt.Sprintf("SELECT * FROM `{{ $table.Name }}` LIMIT %d", MaxLimit+1)
				mock.ExpectQuery(escape(query)).WillReturnRows(sqlmock.NewRows([]string{"10"}))
			},
		},
		{{- range $f := $table.Fields }}
			{{- if $f.RelManyToMany }}
				{
					parent: "{{ $f.Name | camel | plural }}",
					parentName: "1",
					filter: nil,
					before: func(mock sqlmock.Sqlmock) {
						query := fmt.Sprintf("SELECT {{ $f.Rel.JoinTable.JoinField.Name }} FROM `{{ $f.Rel.JoinTable.Name }}` WHERE {{ $f.Rel.JoinTable.JoinRefField.Name }} = ?")
				mock.ExpectQuery(escape(query)).WithArgs("1").WillReturnRows(sqlmock.NewRows([]string{"{{ $f.Rel.JoinTable.JoinField.Name }}"}).AddRow("10"))
						query = fmt.Sprintf("SELECT count(*) FROM `{{ $table.Name }}` WHERE {{ $table.ID.Name }} IN (?) LIMIT %d", MaxLimit+1)
				mock.ExpectQuery(escape(query)).WithArgs("10").WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(1))
						query = fmt.Sprintf("SELECT * FROM `{{ $table.Name }}` WHERE {{  $table.ID.Name }} IN (?) LIMIT %d", MaxLimit+1)
						mock.ExpectQuery(escape(query)).WithArgs("10").WillReturnRows(sqlmock.NewRows([]string{}))
					},
				},
			{{- end }}
			{{- if $f.RelBelongsTo }}
				{
					parent: "{{ $f.Name | camel | plural }}",
					parentName: "1",
					filter: nil,
					before: func(mock sqlmock.Sqlmock) {
						query := fmt.Sprintf("SELECT count(*) FROM `{{ $table.Name }}` WHERE {{  $table.ID.Name }} = ? LIMIT %d", MaxLimit+1)
						mock.ExpectQuery(escape(query)).WithArgs("1").WillReturnRows(sqlmock.NewRows([]string{"10"}))
						query = fmt.Sprintf("SELECT * FROM `{{ $table.Name }}` WHERE {{  $table.ID.Name }} = ? LIMIT %d", MaxLimit+1)
						mock.ExpectQuery(escape(query)).WithArgs("1").WillReturnRows(sqlmock.NewRows([]string{"10"}))
					},
				},
			{{- end }}
		{{- end }}
		{{/*TODO: op test */}}
		{{- if and $table.HasFilterField false}}
			{{- $f := index $table.FilterFields 0 }}
			{
				parent: "",
				parentName: "",
				filter: filter,
				before: func(mock sqlmock.Sqlmock) {
					query := fmt.Sprintf("SELECT count(*) FROM `{{ $table.Name }}` WHERE (`{{ $f.Name }}` = ? AND `{{ $f.Name }}` <> ? AND (`{{ $f.Name }}` = ? OR `{{ $f.Name }}` = ?) AND (`{{ $f.Name }}` = ? AND `{{ $f.Name }}` = ?)) LIMIT %d", MaxLimit+1)
					mock.ExpectQuery(escape(query)).WithArgs(filterValue1, filterValue1, filterValue1, filterValue2, filterValue1, filterValue2).WillReturnRows(sqlmock.NewRows([]string{"10"}))
					query = fmt.Sprintf("SELECT * FROM `{{ $table.Name }}` WHERE (`{{ $f.Name }}` = ? AND `{{ $f.Name }}` <> ? AND (`{{ $f.Name }}` = ? OR `{{ $f.Name }}` = ?) AND (`{{ $f.Name }}` = ? AND `{{ $f.Name }}` = ?)) LIMIT %d", MaxLimit+1)
					mock.ExpectQuery(escape(query)).WithArgs(filterValue1, filterValue1, filterValue1, filterValue2, filterValue1, filterValue2).WillReturnRows(sqlmock.NewRows([]string{"10"}))

				},
			},
		{{- end}}
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock)
			repo := &repository{db: db}
			ctx := context.Background()
			_, _, _, err := repo.List{{ $table.Name | pascal | plural }}(ctx, result.parent, result.parentName, result.filter, result.orderBy, result.count, result.token, false)
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $table.Name | pascal }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}

{{- range $f := $table.Fields}}
	{{- if not $f.Remote }}
		{{- if $f.Filterable }}
			func TestGet{{ $table.Name | pascal }}By{{ $f.Name | pascal }}(t *testing.T) {
				sqlDB, mock, err := sqlmock.New()
				if err != nil {
					t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
				}
				defer sqlDB.Close()
				db, err := gorm.Open(mysql.New(mysql.Config{
					Conn:                      sqlDB,
					SkipInitializeWithVersion: true,
				}), &gorm.Config{
					DisableAutomaticPing: true,
				})

				testModel := &models.{{ $table.Name | pascal }}{}
				faker.FakeData(&testModel)

				results := []struct {
					model   *models.{{ $table.Name | pascal }}
					before  func(sqlmock.Sqlmock, *models.{{ $table.Name | pascal }})
					wantErr bool
				}{
					{
						model: testModel,
						before: func(mock sqlmock.Sqlmock, model *models.{{ $table.Name | pascal }}) {
							querySql := fmt.Sprintf("SELECT * FROM `{{ $table.Name }}` WHERE `{{ $f.Name }}` IN (?)")
							mock.ExpectQuery(escape(querySql)).WithArgs(model.{{ $f.Name | pascal }}).WillReturnRows(sqlmock.NewRows([]string{"{{ $f.Name }}"}).AddRow(model.{{ $f.Name | pascal }}))
						},
					},
				}

				for idx, result := range results {
					t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
						result.before(mock, result.model)
						repo := &repository{db: db}
						ctx := context.Background()
						_, err := repo.Get{{ $table.Name | pascal }}By{{ $f.Name | pascal }}(ctx, result.model.{{ $f.Name | pascal }}, false)
						if err != nil {
							t.Fatalf("an error '%s' was not expected while {{ $table.Name | pascal }}", err)
						}
						if err := mock.ExpectationsWereMet(); err != nil {
							t.Errorf("there were unfulfilled expectations: %s", err)
						}

					})
				}
			}

			func TestBatchGet{{ $table.Name | pascal }}By{{ $f.Name | pascal }}(t *testing.T) {
				sqlDB, mock, err := sqlmock.New()
				if err != nil {
					t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
				}
				defer sqlDB.Close()
				db, err := gorm.Open(mysql.New(mysql.Config{
					Conn:                      sqlDB,
					SkipInitializeWithVersion: true,
				}), &gorm.Config{
					DisableAutomaticPing: true,
				})

				var {{ $table.ID.Name | camel }}1, {{ $table.ID.Name | camel }}2 {{ $table.ID.Type.Kind }}
				faker.FakeData(&{{ $table.ID.Name | camel }}1)
				faker.FakeData(&{{ $table.ID.Name | camel }}2)

				results := []struct {
					{{ $table.ID.Name | camel | plural }}     []{{ $table.ID.Type.Kind }}
					before  func(sqlmock.Sqlmock, []{{ $table.ID.Type.Kind }})
					wantErr bool
				}{
					{
						{{ $table.ID.Name | camel | plural }}: []{{ $table.ID.Type.Kind }}{ {{ $table.ID.Name | camel }}1, {{ $table.ID.Name | camel }}2},
						before: func(mock sqlmock.Sqlmock, {{ $table.ID.Name | camel | plural }} []{{ $table.ID.Type.Kind }}) {
							querySql := fmt.Sprintf("SELECT * FROM `{{ $table.Name }}` WHERE `{{ $f.Name }}` IN (?,?)")
							mock.ExpectQuery(escape(querySql)).WithArgs(sqlmock.AnyArg(), sqlmock.AnyArg()).WillReturnRows(sqlmock.NewRows([]string{"{{ $f.Name }}"}).AddRow({{ $table.ID.Name | camel | plural }}[0]))
						},
					},
				}

				for idx, result := range results {
					t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
						result.before(mock, result.{{ $table.ID.Name | camel | plural }})
						repo := &repository{db: db}
						ctx := context.Background()
						_, err := repo.BatchGet{{ $table.Name | pascal }}By{{ $f.Name | pascal }}(ctx, result.{{ $table.ID.Name | camel | plural }}, false)
						if err != nil {
							t.Fatalf("an error '%s' was not expected while {{ $table.Name | pascal }}", err)
						}
						if err := mock.ExpectationsWereMet(); err != nil {
							t.Errorf("there were unfulfilled expectations: %s", err)
						}

					})
				}
			}
		{{- end}}
	{{- end}}
{{- end}}

func TestCreate{{ $table.Name | pascal }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	testModel := &models.{{ $table.Name | pascal }}{}
	{{- range $f := $table.Fields }}
		{{- if $f.RelNone }}
			{{- if not $f.AutoIncrement }}
				faker.FakeData(&testModel.{{ $f.Name | pascal }})
			{{- end }}
		{{- end }}
	{{- end }}

	results := []struct {
		model 	*models.{{ $table.Name | pascal }}
		before  func(sqlmock.Sqlmock, *models.{{ $table.Name | pascal }})
		wantErr bool
	}{
		{
			model: testModel,
			before: func(mock sqlmock.Sqlmock, model *models.{{ $table.Name | pascal }}) {
				mock.ExpectBegin()
				insertSql := fmt.Sprintf("INSERT INTO `{{ $table.Name }}`")
				mock.ExpectExec(insertSql).WithArgs(
				{{- range $f := $table.Fields -}}
					{{- if $f.RelNone -}}
						{{- if not $f.AutoIncrement -}}
							model.{{- $f.Name | pascal -}},
						{{- end -}}
					{{- end -}}
				{{- end -}}
				).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock, result.model)
			repo := &repository{db: db}
			ctx := context.Background()
			_, err := repo.Create{{ $table.Name | pascal }}(ctx, result.model)
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $table.Name | pascal }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}

func TestUpdate{{ $table.Name | pascal }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	testModel := &models.{{ $table.Name | pascal }}{}
	faker.FakeData(&testModel)

	results := []struct {
		model 	*models.{{ $table.Name | pascal }}
		mask    []string
		before  func(sqlmock.Sqlmock, *models.{{ $table.Name | pascal }})
		wantErr bool
	}{
		{
			model: testModel,
			mask:  []string{},
			before: func(mock sqlmock.Sqlmock, model *models.{{ $table.Name | pascal }}) {
				mock.ExpectBegin()
				updateSql := fmt.Sprintf("UPDATE `{{ $table.Name }}` SET (.+) WHERE `{{$table.ID.Name}}` = ?")
				mock.ExpectExec(updateSql).WithArgs(
				{{- range $f := $table.Fields -}}
					{{- if $f.RelNone -}}
						{{- if not .AutoIncrement -}}
							model.{{- $f.Name | pascal -}},
						{{- end -}}
					{{- end -}}
				{{- end -}}model.{{ $table.ID.Name | pascal }}).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
		{{- $masks := list }}
		{{- $setNames := list }}
		{{- $setArgs := list }}
		{{- range $f := $table.Fields -}}
			{{- if $f.RelNone -}}
				{{- if not .AutoIncrement -}}
					{{- $masks = append $masks (printf "\"%s\"" ( $f.Name | pascal ) ) }}
					{{- $setNames = append $setNames (printf "`%s`=?" $f.Name) }}
					{{- $setArgs = append $setArgs (printf "model.%s" ( $f.Name | pascal ) ) }}
				{{- end -}}
			{{- end -}}
		{{- end -}}
		{
			model: testModel,
			mask:  []string{ {{ join ", " $masks }} },
			before: func(mock sqlmock.Sqlmock, model *models.{{ $table.Name | pascal }}) {
				mock.ExpectBegin()
				updateSql := fmt.Sprintf("UPDATE `{{ $table.Name }}` SET {{ join "," $setNames }} WHERE `{{$table.ID.Name}}` = ?")
				mock.ExpectExec(escape(updateSql)).WithArgs({{ join ", " $setArgs }}, model.{{ $table.ID.Name | pascal }},).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock, result.model)
			repo := &repository{db: db}
			ctx := context.Background()
			_, err := repo.Update{{ $table.Name | pascal }}(ctx, result.model, result.mask)
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $table.Name | pascal }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}

func TestDelete{{ $table.Name | pascal }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	var {{ $table.ID.Name | camel }} {{ $table.ID.Type.Kind }}
	faker.FakeData(&{{ $table.ID.Name | camel }})

	results := []struct {
		{{ $table.ID.Name | camel }}     {{ $table.ID.Type.Kind }}
		before  func(sqlmock.Sqlmock, {{ $table.ID.Type.Kind }})
		wantErr bool
	}{
		{
			{{ $table.ID.Name | camel }}: {{ $table.ID.Name | camel }},
			before: func(mock sqlmock.Sqlmock, {{ $table.ID.Name | camel }} {{ $table.ID.Type.Kind }}) {
				mock.ExpectBegin()
				deleteSql := fmt.Sprintf("DELETE FROM `{{ $table.Name }}` WHERE `{{$table.ID.Name}}` IN (?)")
				mock.ExpectExec(escape(deleteSql)).WithArgs(sqlmock.AnyArg()).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock, result.{{ $table.ID.Name | camel }})
			repo := &repository{db: db}
			ctx := context.Background()
			err := repo.Delete{{ $table.Name | pascal }}(ctx, result.{{ $table.ID.Name | camel }})
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $table.Name | pascal }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}

func TestBatchDelete{{ $table.Name | pascal }}(t *testing.T) {
	sqlDB, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)
	}
	defer sqlDB.Close()
	db, err := gorm.Open(mysql.New(mysql.Config{
		Conn:                      sqlDB,
		SkipInitializeWithVersion: true,
	}), &gorm.Config{
		DisableAutomaticPing: true,
	})

	var {{ $table.ID.Name | camel }}1, {{ $table.ID.Name | camel }}2 {{ $table.ID.Type.Kind }}
	faker.FakeData(&{{ $table.ID.Name | camel }}1)
	faker.FakeData(&{{ $table.ID.Name | camel }}2)

	results := []struct {
		{{ $table.ID.Name | camel | plural }}     []{{ $table.ID.Type.Kind }}
		before  func(sqlmock.Sqlmock, []{{ $table.ID.Type.Kind }})
		wantErr bool
	}{
		{
			{{ $table.ID.Name | camel | plural }}: []{{ $table.ID.Type.Kind }}{ {{ $table.ID.Name | camel }}1, {{ $table.ID.Name | camel }}2},
			before: func(mock sqlmock.Sqlmock, {{ $table.ID.Name | camel | plural }} []{{ $table.ID.Type.Kind }}) {
				mock.ExpectBegin()
				deleteSql := fmt.Sprintf("DELETE FROM `{{ $table.Name }}` WHERE `{{$table.ID.Name}}` IN (?,?)")
				mock.ExpectExec(escape(deleteSql)).WithArgs(sqlmock.AnyArg(), sqlmock.AnyArg()).WillReturnResult(sqlmock.NewResult(1, 1))
				mock.ExpectCommit()
			},
		},
	}

	for idx, result := range results {
		t.Run(fmt.Sprintf("case #%v", idx), func(t *testing.T) {
			result.before(mock, result.{{ $table.ID.Name | camel | plural }})
			repo := &repository{db: db}
			ctx := context.Background()
			err := repo.BatchDelete{{ $table.Name | pascal }}(ctx, result.{{ $table.ID.Name | camel | plural }})
			if err != nil {
				t.Fatalf("an error '%s' was not expected while {{ $table.Name | pascal }}", err)
			}
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("there were unfulfilled expectations: %s", err)
			}

		})
	}
}